import {
  require_events
} from "./chunk-XOXFHKFA.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/obliterator/iterator.js
var require_iterator = __commonJS({
  "node_modules/obliterator/iterator.js"(exports, module) {
    function Iterator2(next) {
      Object.defineProperty(this, "_next", {
        writable: false,
        enumerable: false,
        value: next
      });
      this.done = false;
    }
    Iterator2.prototype.next = function() {
      if (this.done)
        return { done: true };
      var step = this._next();
      if (step.done)
        this.done = true;
      return step;
    };
    if (typeof Symbol !== "undefined")
      Iterator2.prototype[Symbol.iterator] = function() {
        return this;
      };
    Iterator2.of = function() {
      var args = arguments, l = args.length, i = 0;
      return new Iterator2(function() {
        if (i >= l)
          return { done: true };
        return { done: false, value: args[i++] };
      });
    };
    Iterator2.empty = function() {
      var iterator = new Iterator2(null);
      iterator.done = true;
      return iterator;
    };
    Iterator2.is = function(value) {
      if (value instanceof Iterator2)
        return true;
      return typeof value === "object" && value !== null && typeof value.next === "function";
    };
    module.exports = Iterator2;
  }
});

// node_modules/obliterator/take.js
var require_take = __commonJS({
  "node_modules/obliterator/take.js"(exports, module) {
    module.exports = function take2(iterator, n) {
      var l = arguments.length > 1 ? n : Infinity, array = l !== Infinity ? new Array(l) : [], step, i = 0;
      while (true) {
        if (i === l)
          return array;
        step = iterator.next();
        if (step.done) {
          if (i !== n)
            return array.slice(0, i);
          return array;
        }
        array[i++] = step.value;
      }
    };
  }
});

// node_modules/obliterator/chain.js
var require_chain = __commonJS({
  "node_modules/obliterator/chain.js"(exports, module) {
    var Iterator2 = require_iterator();
    module.exports = function chain2() {
      var iterators = arguments, current, i = -1;
      return new Iterator2(function iterate() {
        if (!current) {
          i++;
          if (i >= iterators.length)
            return { done: true };
          current = iterators[i];
        }
        var step = current.next();
        if (step.done) {
          current = null;
          return iterate();
        }
        return step;
      });
    };
  }
});

// node_modules/graphology/dist/graphology.esm.js
var import_events = __toESM(require_events());
var import_iterator = __toESM(require_iterator());
var import_take = __toESM(require_take());
var import_chain = __toESM(require_chain());
function assignPolyfill() {
  const target = arguments[0];
  for (let i = 1, l = arguments.length; i < l; i++) {
    if (!arguments[i])
      continue;
    for (const k in arguments[i])
      target[k] = arguments[i][k];
  }
  return target;
}
var assign = assignPolyfill;
if (typeof Object.assign === "function")
  assign = Object.assign;
function getMatchingEdge(graph, source, target, type) {
  const sourceData = graph._nodes.get(source);
  let edge = null;
  if (!sourceData)
    return edge;
  if (type === "mixed") {
    edge = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target];
  } else if (type === "directed") {
    edge = sourceData.out && sourceData.out[target];
  } else {
    edge = sourceData.undirected && sourceData.undirected[target];
  }
  return edge;
}
function isGraph(value) {
  return value !== null && typeof value === "object" && typeof value.addUndirectedEdgeWithKey === "function" && typeof value.dropNode === "function";
}
function isPlainObject(value) {
  return typeof value === "object" && value !== null && value.constructor === Object;
}
function isEmpty(o) {
  let k;
  for (k in o)
    return false;
  return true;
}
function privateProperty(target, name, value) {
  Object.defineProperty(target, name, {
    enumerable: false,
    configurable: false,
    writable: true,
    value
  });
}
function readOnlyProperty(target, name, value) {
  const descriptor = {
    enumerable: true,
    configurable: true
  };
  if (typeof value === "function") {
    descriptor.get = value;
  } else {
    descriptor.value = value;
    descriptor.writable = false;
  }
  Object.defineProperty(target, name, descriptor);
}
function validateHints(hints) {
  if (!isPlainObject(hints))
    return false;
  if (hints.attributes && !Array.isArray(hints.attributes))
    return false;
  return true;
}
function incrementalId() {
  let i = 0;
  return () => {
    return i++;
  };
}
var GraphError = class extends Error {
  constructor(message, data) {
    super();
    this.name = "GraphError";
    this.message = message || "";
    this.data = data || {};
  }
};
var InvalidArgumentsGraphError = class _InvalidArgumentsGraphError extends GraphError {
  constructor(message, data) {
    super(message, data);
    this.name = "InvalidArgumentsGraphError";
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, _InvalidArgumentsGraphError.prototype.constructor);
  }
};
var NotFoundGraphError = class _NotFoundGraphError extends GraphError {
  constructor(message, data) {
    super(message, data);
    this.name = "NotFoundGraphError";
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, _NotFoundGraphError.prototype.constructor);
  }
};
var UsageGraphError = class _UsageGraphError extends GraphError {
  constructor(message, data) {
    super(message, data);
    this.name = "UsageGraphError";
    if (typeof Error.captureStackTrace === "function")
      Error.captureStackTrace(this, _UsageGraphError.prototype.constructor);
  }
};
function MixedNodeData(key, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.inDegree = 0;
  this.outDegree = 0;
  this.undirectedDegree = 0;
  this.directedSelfLoops = 0;
  this.undirectedSelfLoops = 0;
  this.in = {};
  this.out = {};
  this.undirected = {};
}
function DirectedNodeData(key, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.inDegree = 0;
  this.outDegree = 0;
  this.directedSelfLoops = 0;
  this.in = {};
  this.out = {};
}
DirectedNodeData.prototype.upgradeToMixed = function() {
  this.undirectedDegree = 0;
  this.undirectedSelfLoops = 0;
  this.undirected = {};
};
function UndirectedNodeData(key, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.undirectedDegree = 0;
  this.undirectedSelfLoops = 0;
  this.undirected = {};
}
UndirectedNodeData.prototype.upgradeToMixed = function() {
  this.inDegree = 0;
  this.outDegree = 0;
  this.directedSelfLoops = 0;
  this.in = {};
  this.out = {};
};
function EdgeData(undirected, key, generatedKey, source, target, attributes) {
  this.key = key;
  this.attributes = attributes;
  this.undirected = undirected;
  this.source = source;
  this.target = target;
  this.generatedKey = generatedKey;
}
function updateStructureIndex(graph, undirected, edgeData, source, target, sourceData, targetData) {
  const multi = graph.multi;
  let outKey = "out";
  let inKey = "in";
  if (undirected)
    outKey = inKey = "undirected";
  let adj, container;
  if (multi) {
    adj = sourceData[outKey];
    container = adj[target];
    if (typeof container === "undefined") {
      container = /* @__PURE__ */ new Set();
      adj[target] = container;
    }
    container.add(edgeData);
    if (source === target && undirected)
      return;
    adj = targetData[inKey];
    if (typeof adj[source] === "undefined")
      adj[source] = container;
  } else {
    sourceData[outKey][target] = edgeData;
    if (source === target && undirected)
      return;
    targetData[inKey][source] = edgeData;
  }
}
function clearEdgeFromStructureIndex(graph, undirected, edgeData) {
  const multi = graph.multi;
  const { source: sourceData, target: targetData } = edgeData;
  const source = sourceData.key, target = targetData.key;
  const outKey = undirected ? "undirected" : "out", sourceIndex = sourceData[outKey];
  const inKey = undirected ? "undirected" : "in";
  if (target in sourceIndex) {
    if (multi) {
      const set = sourceIndex[target];
      if (set.size === 1) {
        delete sourceIndex[target];
        delete targetData[inKey][source];
      } else {
        set.delete(edgeData);
      }
    } else
      delete sourceIndex[target];
  }
  if (multi)
    return;
  const targetIndex = targetData[inKey];
  delete targetIndex[source];
}
function clearStructureIndex(graph) {
  graph._nodes.forEach((data) => {
    if (typeof data.in !== "undefined") {
      data.in = {};
      data.out = {};
    }
    if (typeof data.undirected !== "undefined") {
      data.undirected = {};
    }
  });
}
function upgradeStructureIndexToMulti(graph) {
  graph._nodes.forEach((data, node) => {
    if (data.out) {
      for (const neighbor in data.out) {
        const edges = /* @__PURE__ */ new Set();
        edges.add(data.out[neighbor]);
        data.out[neighbor] = edges;
        graph._nodes.get(neighbor).in[node] = edges;
      }
    }
    if (data.undirected) {
      for (const neighbor in data.undirected) {
        if (neighbor > node)
          continue;
        const edges = /* @__PURE__ */ new Set();
        edges.add(data.undirected[neighbor]);
        data.undirected[neighbor] = edges;
        graph._nodes.get(neighbor).undirected[node] = edges;
      }
    }
  });
}
function attachAttributeGetter(Class, method, type) {
  Class.prototype[method] = function(element, name) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + name;
      name = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    return data.attributes[name];
  };
}
function attachAttributesGetter(Class, method, type) {
  Class.prototype[method] = function(element) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 1) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + arguments[1];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    return data.attributes;
  };
}
function attachAttributeChecker(Class, method, type) {
  Class.prototype[method] = function(element, name) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + name;
      name = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    return data.attributes.hasOwnProperty(name);
  };
}
function attachAttributeSetter(Class, method, type) {
  Class.prototype[method] = function(element, name, value) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + name;
      name = arguments[2];
      value = arguments[3];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    data.attributes[name] = value;
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachAttributeUpdater(Class, method, type) {
  Class.prototype[method] = function(element, name, updater) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + name;
      name = arguments[2];
      updater = arguments[3];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    data.attributes[name] = updater(data.attributes[name]);
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachAttributeRemover(Class, method, type) {
  Class.prototype[method] = function(element, name) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + name;
      name = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    delete data.attributes[name];
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "remove",
      attributes: data.attributes,
      name
    });
    return this;
  };
}
function attachAttributesReplacer(Class, method, type) {
  Class.prototype[method] = function(element, attributes) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + attributes;
      attributes = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    data.attributes = attributes;
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "replace",
      attributes: data.attributes
    });
    return this;
  };
}
function attachAttributesMerger(Class, method, type) {
  Class.prototype[method] = function(element, attributes) {
    let data;
    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);
    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);
      const source = "" + element, target = "" + attributes;
      attributes = arguments[2];
      data = getMatchingEdge(this, source, target, type);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`);
    } else {
      element = "" + element;
      data = this._edges.get(element);
      if (!data)
        throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" edge in the graph.`);
    }
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);
    if (type !== "mixed" && data.undirected !== (type === "undirected"))
      throw new NotFoundGraphError(`Graph.${method}: could not find the "${element}" ${type} edge in the graph.`);
    assign(data.attributes, attributes);
    this.emit("edgeAttributesUpdated", {
      key: data.key,
      type: "merge",
      attributes: data.attributes,
      data: attributes
    });
    return this;
  };
}
var ATTRIBUTES_METHODS = [
  {
    name: (element) => `get${element}Attribute`,
    attacher: attachAttributeGetter
  },
  {
    name: (element) => `get${element}Attributes`,
    attacher: attachAttributesGetter
  },
  {
    name: (element) => `has${element}Attribute`,
    attacher: attachAttributeChecker
  },
  {
    name: (element) => `set${element}Attribute`,
    attacher: attachAttributeSetter
  },
  {
    name: (element) => `update${element}Attribute`,
    attacher: attachAttributeUpdater
  },
  {
    name: (element) => `remove${element}Attribute`,
    attacher: attachAttributeRemover
  },
  {
    name: (element) => `replace${element}Attributes`,
    attacher: attachAttributesReplacer
  },
  {
    name: (element) => `merge${element}Attributes`,
    attacher: attachAttributesMerger
  }
];
function attachAttributesMethods(Graph2) {
  ATTRIBUTES_METHODS.forEach(function({ name, attacher }) {
    attacher(
      Graph2,
      name("Edge"),
      "mixed"
    );
    attacher(
      Graph2,
      name("DirectedEdge"),
      "directed"
    );
    attacher(
      Graph2,
      name("UndirectedEdge"),
      "undirected"
    );
  });
}
var EDGES_ITERATION = [
  {
    name: "edges",
    type: "mixed"
  },
  {
    name: "inEdges",
    type: "directed",
    direction: "in"
  },
  {
    name: "outEdges",
    type: "directed",
    direction: "out"
  },
  {
    name: "inboundEdges",
    type: "mixed",
    direction: "in"
  },
  {
    name: "outboundEdges",
    type: "mixed",
    direction: "out"
  },
  {
    name: "directedEdges",
    type: "directed"
  },
  {
    name: "undirectedEdges",
    type: "undirected"
  }
];
function collectSimple(edges, object) {
  for (const k in object)
    edges.push(object[k].key);
}
function collectMulti(edges, object) {
  for (const k in object)
    object[k].forEach((edgeData) => edges.push(edgeData.key));
}
function forEachSimple(object, callback, avoid) {
  for (const k in object) {
    if (k === avoid)
      continue;
    const edgeData = object[k];
    callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected,
      edgeData.generatedKey
    );
  }
}
function forEachMulti(object, callback, avoid) {
  for (const k in object) {
    if (k === avoid)
      continue;
    object[k].forEach((edgeData) => callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected,
      edgeData.generatedKey
    ));
  }
}
function forEachSimpleUntil(object, callback, avoid) {
  let shouldBreak = false;
  for (const k in object) {
    if (k === avoid)
      continue;
    const edgeData = object[k];
    shouldBreak = callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected,
      edgeData.generatedKey
    );
    if (shouldBreak)
      return true;
  }
  return false;
}
function forEachMultiUntil(object, callback, avoid) {
  let iterator, step, edgeData, source, target;
  let shouldBreak = false;
  for (const k in object) {
    if (k === avoid)
      continue;
    iterator = object[k].values();
    while (step = iterator.next(), step.done !== true) {
      edgeData = step.value;
      source = edgeData.source;
      target = edgeData.target;
      shouldBreak = callback(
        edgeData.key,
        edgeData.attributes,
        source.key,
        target.key,
        source.attributes,
        target.attributes,
        edgeData.undirected,
        edgeData.generatedKey
      );
      if (shouldBreak)
        return true;
    }
  }
  return false;
}
function createIterator(object, avoid) {
  const keys = Object.keys(object), l = keys.length;
  let inner = null, i = 0;
  return new import_iterator.default(function next() {
    let edgeData;
    if (inner) {
      const step = inner.next();
      if (step.done) {
        inner = null;
        i++;
        return next();
      }
      edgeData = step.value;
    } else {
      if (i >= l)
        return { done: true };
      const k = keys[i];
      if (k === avoid) {
        i++;
        return next();
      }
      edgeData = object[k];
      if (edgeData instanceof Set) {
        inner = edgeData.values();
        return next();
      }
      i++;
    }
    return {
      done: false,
      value: [
        edgeData.key,
        edgeData.attributes,
        edgeData.source.key,
        edgeData.target.key,
        edgeData.source.attributes,
        edgeData.target.attributes
      ]
    };
  });
}
function collectForKeySimple(edges, object, k) {
  const edgeData = object[k];
  if (!edgeData)
    return;
  edges.push(edgeData.key);
}
function collectForKeyMulti(edges, object, k) {
  const edgesData = object[k];
  if (!edgesData)
    return;
  edgesData.forEach((edgeData) => edges.push(edgeData.key));
}
function forEachForKeySimple(object, k, callback) {
  const edgeData = object[k];
  if (!edgeData)
    return;
  const sourceData = edgeData.source;
  const targetData = edgeData.target;
  callback(
    edgeData.key,
    edgeData.attributes,
    sourceData.key,
    targetData.key,
    sourceData.attributes,
    targetData.attributes,
    edgeData.undirected,
    edgeData.generatedKey
  );
}
function forEachForKeyMulti(object, k, callback) {
  const edgesData = object[k];
  if (!edgesData)
    return;
  edgesData.forEach((edgeData) => callback(
    edgeData.key,
    edgeData.attributes,
    edgeData.source.key,
    edgeData.target.key,
    edgeData.source.attributes,
    edgeData.target.attributes,
    edgeData.undirected,
    edgeData.generatedKey
  ));
}
function forEachForKeySimpleUntil(object, k, callback) {
  const edgeData = object[k];
  if (!edgeData)
    return false;
  const sourceData = edgeData.source;
  const targetData = edgeData.target;
  return callback(
    edgeData.key,
    edgeData.attributes,
    sourceData.key,
    targetData.key,
    sourceData.attributes,
    targetData.attributes,
    edgeData.undirected,
    edgeData.generatedKey
  );
}
function forEachForKeyMultiUntil(object, k, callback) {
  const edgesData = object[k];
  if (!edgesData)
    return false;
  let shouldBreak = false;
  const iterator = edgesData.values();
  let step, edgeData;
  while (step = iterator.next(), step.done !== true) {
    edgeData = step.value;
    shouldBreak = callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected,
      edgeData.generatedKey
    );
    if (shouldBreak)
      return true;
  }
  return false;
}
function createIteratorForKey(object, k) {
  const v = object[k];
  if (v instanceof Set) {
    const iterator = v.values();
    return new import_iterator.default(function() {
      const step = iterator.next();
      if (step.done)
        return step;
      const edgeData = step.value;
      return {
        done: false,
        value: [
          edgeData.key,
          edgeData.attributes,
          edgeData.source.key,
          edgeData.target.key,
          edgeData.source.attributes,
          edgeData.target.attributes
        ]
      };
    });
  }
  return import_iterator.default.of([
    v.key,
    v.attributes,
    v.source.key,
    v.target.key,
    v.source.attributes,
    v.target.attributes
  ]);
}
function createEdgeArray(graph, type) {
  if (graph.size === 0)
    return [];
  if (type === "mixed" || type === graph.type) {
    if (typeof Array.from === "function")
      return Array.from(graph._edges.keys());
    return (0, import_take.default)(graph._edges.keys(), graph._edges.size);
  }
  const size = type === "undirected" ? graph.undirectedSize : graph.directedSize;
  const list = new Array(size), mask = type === "undirected";
  const iterator = graph._edges.values();
  let i = 0;
  let step, data;
  while (step = iterator.next(), step.done !== true) {
    data = step.value;
    if (data.undirected === mask)
      list[i++] = data.key;
  }
  return list;
}
function forEachEdge(graph, type, callback) {
  if (graph.size === 0)
    return;
  const shouldFilter = type !== "mixed" && type !== graph.type;
  const mask = type === "undirected";
  let step, data;
  const iterator = graph._edges.values();
  while (step = iterator.next(), step.done !== true) {
    data = step.value;
    if (shouldFilter && data.undirected !== mask)
      continue;
    const { key, attributes, source, target } = data;
    callback(
      key,
      attributes,
      source.key,
      target.key,
      source.attributes,
      target.attributes,
      data.undirected,
      data.generatedKey
    );
  }
}
function forEachEdgeUntil(graph, type, callback) {
  if (graph.size === 0)
    return false;
  const shouldFilter = type !== "mixed" && type !== graph.type;
  const mask = type === "undirected";
  let step, data;
  let shouldBreak = false;
  const iterator = graph._edges.values();
  while (step = iterator.next(), step.done !== true) {
    data = step.value;
    if (shouldFilter && data.undirected !== mask)
      continue;
    const { key, attributes, source, target } = data;
    shouldBreak = callback(
      key,
      attributes,
      source.key,
      target.key,
      source.attributes,
      target.attributes,
      data.undirected,
      data.generatedKey
    );
    if (shouldBreak)
      return true;
  }
  return false;
}
function createEdgeIterator(graph, type) {
  if (graph.size === 0)
    return import_iterator.default.empty();
  const shouldFilter = type !== "mixed" && type !== graph.type;
  const mask = type === "undirected";
  const iterator = graph._edges.values();
  return new import_iterator.default(function next() {
    let step, data;
    while (true) {
      step = iterator.next();
      if (step.done)
        return step;
      data = step.value;
      if (shouldFilter && data.undirected !== mask)
        continue;
      break;
    }
    const value = [
      data.key,
      data.attributes,
      data.source.key,
      data.target.key,
      data.source.attributes,
      data.target.attributes
    ];
    return { value, done: false };
  });
}
function createEdgeArrayForNode(multi, type, direction, nodeData) {
  const edges = [];
  const fn = multi ? collectMulti : collectSimple;
  if (type !== "undirected") {
    if (direction !== "out")
      fn(edges, nodeData.in);
    if (direction !== "in")
      fn(edges, nodeData.out);
    if (!direction && nodeData.directedSelfLoops > 0)
      edges.splice(edges.lastIndexOf(nodeData.key), 1);
  }
  if (type !== "directed") {
    fn(edges, nodeData.undirected);
  }
  return edges;
}
function forEachEdgeForNode(multi, type, direction, nodeData, callback) {
  const fn = multi ? forEachMulti : forEachSimple;
  if (type !== "undirected") {
    if (direction !== "out")
      fn(nodeData.in, callback);
    if (direction !== "in")
      fn(nodeData.out, callback, !direction ? nodeData.key : null);
  }
  if (type !== "directed") {
    fn(nodeData.undirected, callback);
  }
}
function forEachEdgeForNodeUntil(multi, type, direction, nodeData, callback) {
  const fn = multi ? forEachMultiUntil : forEachSimpleUntil;
  let shouldBreak = false;
  if (type !== "undirected") {
    if (direction !== "out") {
      shouldBreak = fn(nodeData.in, callback);
      if (shouldBreak)
        return true;
    }
    if (direction !== "in") {
      shouldBreak = fn(nodeData.out, callback, !direction ? nodeData.key : null);
      if (shouldBreak)
        return true;
    }
  }
  if (type !== "directed") {
    shouldBreak = fn(nodeData.undirected, callback);
    if (shouldBreak)
      return true;
  }
  return false;
}
function createEdgeIteratorForNode(type, direction, nodeData) {
  let iterator = import_iterator.default.empty();
  if (type !== "undirected") {
    if (direction !== "out" && typeof nodeData.in !== "undefined")
      iterator = (0, import_chain.default)(iterator, createIterator(nodeData.in));
    if (direction !== "in" && typeof nodeData.out !== "undefined")
      iterator = (0, import_chain.default)(iterator, createIterator(nodeData.out, !direction ? nodeData.key : null));
  }
  if (type !== "directed" && typeof nodeData.undirected !== "undefined") {
    iterator = (0, import_chain.default)(iterator, createIterator(nodeData.undirected));
  }
  return iterator;
}
function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
  const fn = multi ? collectForKeyMulti : collectForKeySimple;
  const edges = [];
  if (type !== "undirected") {
    if (typeof sourceData.in !== "undefined" && direction !== "out")
      fn(edges, sourceData.in, target);
    if (typeof sourceData.out !== "undefined" && direction !== "in")
      fn(edges, sourceData.out, target);
    if (!direction && sourceData.directedSelfLoops > 0)
      edges.splice(edges.lastIndexOf(sourceData.key), 1);
  }
  if (type !== "directed") {
    if (typeof sourceData.undirected !== "undefined")
      fn(edges, sourceData.undirected, target);
  }
  return edges;
}
function forEachEdgeForPath(type, multi, direction, sourceData, target, callback) {
  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;
  if (type !== "undirected") {
    if (typeof sourceData.in !== "undefined" && direction !== "out")
      fn(sourceData.in, target, callback);
    if (sourceData.key !== target) {
      if (typeof sourceData.out !== "undefined" && direction !== "in")
        fn(sourceData.out, target, callback);
    }
  }
  if (type !== "directed") {
    if (typeof sourceData.undirected !== "undefined")
      fn(sourceData.undirected, target, callback);
  }
}
function forEachEdgeForPathUntil(type, multi, direction, sourceData, target, callback) {
  const fn = multi ? forEachForKeyMultiUntil : forEachForKeySimpleUntil;
  let shouldBreak = false;
  if (type !== "undirected") {
    if (typeof sourceData.in !== "undefined" && direction !== "out") {
      shouldBreak = fn(sourceData.in, target, callback);
      if (shouldBreak)
        return true;
    }
    if (sourceData.key !== target) {
      if (typeof sourceData.out !== "undefined" && direction !== "in") {
        shouldBreak = fn(sourceData.out, target, callback, !direction ? sourceData.key : null);
        if (shouldBreak)
          return true;
      }
    }
  }
  if (type !== "directed") {
    if (typeof sourceData.undirected !== "undefined") {
      shouldBreak = fn(sourceData.undirected, target, callback);
      if (shouldBreak)
        return true;
    }
  }
  return false;
}
function createEdgeIteratorForPath(type, direction, sourceData, target) {
  let iterator = import_iterator.default.empty();
  if (type !== "undirected") {
    if (typeof sourceData.in !== "undefined" && direction !== "out" && target in sourceData.in)
      iterator = (0, import_chain.default)(iterator, createIteratorForKey(sourceData.in, target));
    if (typeof sourceData.out !== "undefined" && direction !== "in" && target in sourceData.out)
      iterator = (0, import_chain.default)(iterator, createIteratorForKey(sourceData.out, target));
  }
  if (type !== "directed") {
    if (typeof sourceData.undirected !== "undefined" && target in sourceData.undirected)
      iterator = (0, import_chain.default)(iterator, createIteratorForKey(sourceData.undirected, target));
  }
  return iterator;
}
function attachEdgeArrayCreator(Class, description) {
  const {
    name,
    type,
    direction
  } = description;
  Class.prototype[name] = function(source, target) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return [];
    if (!arguments.length)
      return createEdgeArray(this, type);
    if (arguments.length === 1) {
      source = "" + source;
      const nodeData = this._nodes.get(source);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(`Graph.${name}: could not find the "${source}" node in the graph.`);
      return createEdgeArrayForNode(
        this.multi,
        type === "mixed" ? this.type : type,
        direction,
        nodeData
      );
    }
    if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${target}" target node in the graph.`);
      return createEdgeArrayForPath(type, this.multi, direction, sourceData, target);
    }
    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);
  };
}
function attachForEachEdge(Class, description) {
  const {
    name,
    type,
    direction
  } = description;
  const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
  Class.prototype[forEachName] = function(source, target, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return;
    if (arguments.length === 1) {
      callback = source;
      return forEachEdge(this, type, callback);
    }
    if (arguments.length === 2) {
      source = "" + source;
      callback = target;
      const nodeData = this._nodes.get(source);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the "${source}" node in the graph.`);
      return forEachEdgeForNode(
        this.multi,
        type === "mixed" ? this.type : type,
        direction,
        nodeData,
        callback
      );
    }
    if (arguments.length === 3) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the "${target}" target node in the graph.`);
      return forEachEdgeForPath(type, this.multi, direction, sourceData, target, callback);
    }
    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);
  };
}
function attachForEachEdgeUntil(Class, description) {
  const {
    name,
    type,
    direction
  } = description;
  const forEachUntilName = "forEach" + name[0].toUpperCase() + name.slice(1, -1) + "Until";
  Class.prototype[forEachUntilName] = function(source, target, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return false;
    if (arguments.length === 1) {
      callback = source;
      return forEachEdgeUntil(this, type, callback);
    }
    if (arguments.length === 2) {
      source = "" + source;
      callback = target;
      const nodeData = this._nodes.get(source);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the "${source}" node in the graph.`);
      return forEachEdgeForNodeUntil(
        this.multi,
        type === "mixed" ? this.type : type,
        direction,
        nodeData,
        callback
      );
    }
    if (arguments.length === 3) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the "${target}" target node in the graph.`);
      return forEachEdgeForPathUntil(type, this.multi, direction, sourceData, target, callback);
    }
    throw new InvalidArgumentsGraphError(`Graph.${forEachUntilName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);
  };
}
function attachEdgeIteratorCreator(Class, description) {
  const {
    name: originalName,
    type,
    direction
  } = description;
  const name = originalName.slice(0, -1) + "Entries";
  Class.prototype[name] = function(source, target) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return import_iterator.default.empty();
    if (!arguments.length)
      return createEdgeIterator(this, type);
    if (arguments.length === 1) {
      source = "" + source;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${name}: could not find the "${source}" node in the graph.`);
      return createEdgeIteratorForNode(type, direction, sourceData);
    }
    if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const sourceData = this._nodes.get(source);
      if (!sourceData)
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${source}" source node in the graph.`);
      if (!this._nodes.has(target))
        throw new NotFoundGraphError(`Graph.${name}:  could not find the "${target}" target node in the graph.`);
      return createEdgeIteratorForPath(type, direction, sourceData, target);
    }
    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);
  };
}
function attachEdgeIterationMethods(Graph2) {
  EDGES_ITERATION.forEach((description) => {
    attachEdgeArrayCreator(Graph2, description);
    attachForEachEdge(Graph2, description);
    attachForEachEdgeUntil(Graph2, description);
    attachEdgeIteratorCreator(Graph2, description);
  });
}
var NEIGHBORS_ITERATION = [
  {
    name: "neighbors",
    type: "mixed"
  },
  {
    name: "inNeighbors",
    type: "directed",
    direction: "in"
  },
  {
    name: "outNeighbors",
    type: "directed",
    direction: "out"
  },
  {
    name: "inboundNeighbors",
    type: "mixed",
    direction: "in"
  },
  {
    name: "outboundNeighbors",
    type: "mixed",
    direction: "out"
  },
  {
    name: "directedNeighbors",
    type: "directed"
  },
  {
    name: "undirectedNeighbors",
    type: "undirected"
  }
];
function merge(neighbors, object) {
  if (typeof object === "undefined")
    return;
  for (const neighbor in object)
    neighbors.add(neighbor);
}
function createNeighborArrayForNode(type, direction, nodeData) {
  if (type !== "mixed") {
    if (type === "undirected")
      return Object.keys(nodeData.undirected);
    if (typeof direction === "string")
      return Object.keys(nodeData[direction]);
  }
  const neighbors = /* @__PURE__ */ new Set();
  if (type !== "undirected") {
    if (direction !== "out") {
      merge(neighbors, nodeData.in);
    }
    if (direction !== "in") {
      merge(neighbors, nodeData.out);
    }
  }
  if (type !== "directed") {
    merge(neighbors, nodeData.undirected);
  }
  return (0, import_take.default)(neighbors.values(), neighbors.size);
}
function forEachInObject(nodeData, object, callback) {
  for (const k in object) {
    let edgeData = object[k];
    if (edgeData instanceof Set)
      edgeData = edgeData.values().next().value;
    const sourceData = edgeData.source, targetData = edgeData.target;
    const neighborData = sourceData === nodeData ? targetData : sourceData;
    callback(
      neighborData.key,
      neighborData.attributes
    );
  }
}
function forEachInObjectOnce(visited, nodeData, object, callback) {
  for (const k in object) {
    let edgeData = object[k];
    if (edgeData instanceof Set)
      edgeData = edgeData.values().next().value;
    const sourceData = edgeData.source, targetData = edgeData.target;
    const neighborData = sourceData === nodeData ? targetData : sourceData;
    if (visited.has(neighborData.key))
      continue;
    visited.add(neighborData.key);
    callback(
      neighborData.key,
      neighborData.attributes
    );
  }
}
function forEachInObjectUntil(nodeData, object, callback) {
  for (const k in object) {
    let edgeData = object[k];
    if (edgeData instanceof Set)
      edgeData = edgeData.values().next().value;
    const sourceData = edgeData.source, targetData = edgeData.target;
    const neighborData = sourceData === nodeData ? targetData : sourceData;
    const shouldBreak = callback(
      neighborData.key,
      neighborData.attributes
    );
    if (shouldBreak)
      return true;
  }
  return false;
}
function forEachInObjectOnceUntil(visited, nodeData, object, callback) {
  for (const k in object) {
    let edgeData = object[k];
    if (edgeData instanceof Set)
      edgeData = edgeData.values().next().value;
    const sourceData = edgeData.source, targetData = edgeData.target;
    const neighborData = sourceData === nodeData ? targetData : sourceData;
    if (visited.has(neighborData.key))
      continue;
    visited.add(neighborData.key);
    const shouldBreak = callback(
      neighborData.key,
      neighborData.attributes
    );
    if (shouldBreak)
      return true;
  }
  return false;
}
function forEachNeighborForNode(type, direction, nodeData, callback) {
  if (type !== "mixed") {
    if (type === "undirected")
      return forEachInObject(nodeData, nodeData.undirected, callback);
    if (typeof direction === "string")
      return forEachInObject(nodeData, nodeData[direction], callback);
  }
  const visited = /* @__PURE__ */ new Set();
  if (type !== "undirected") {
    if (direction !== "out") {
      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);
    }
    if (direction !== "in") {
      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);
    }
  }
  if (type !== "directed") {
    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);
  }
}
function forEachNeighborForNodeUntil(type, direction, nodeData, callback) {
  if (type !== "mixed") {
    if (type === "undirected")
      return forEachInObjectUntil(nodeData, nodeData.undirected, callback);
    if (typeof direction === "string")
      return forEachInObjectUntil(nodeData, nodeData[direction], callback);
  }
  const visited = /* @__PURE__ */ new Set();
  let shouldBreak = false;
  if (type !== "undirected") {
    if (direction !== "out") {
      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.in, callback);
      if (shouldBreak)
        return true;
    }
    if (direction !== "in") {
      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.out, callback);
      if (shouldBreak)
        return true;
    }
  }
  if (type !== "directed") {
    shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.undirected, callback);
    if (shouldBreak)
      return true;
  }
  return false;
}
function createObjectIterator(nodeData, object) {
  const keys = Object.keys(object), l = keys.length;
  let i = 0;
  return new import_iterator.default(function() {
    if (i >= l)
      return { done: true };
    let edgeData = object[keys[i++]];
    if (edgeData instanceof Set)
      edgeData = edgeData.values().next().value;
    const sourceData = edgeData.source, targetData = edgeData.target;
    const neighborData = sourceData === nodeData ? targetData : sourceData;
    return {
      done: false,
      value: [neighborData.key, neighborData.attributes]
    };
  });
}
function createDedupedObjectIterator(visited, nodeData, object) {
  const keys = Object.keys(object), l = keys.length;
  let i = 0;
  return new import_iterator.default(function next() {
    if (i >= l)
      return { done: true };
    let edgeData = object[keys[i++]];
    if (edgeData instanceof Set)
      edgeData = edgeData.values().next().value;
    const sourceData = edgeData.source, targetData = edgeData.target;
    const neighborData = sourceData === nodeData ? targetData : sourceData;
    if (visited.has(neighborData.key))
      return next();
    visited.add(neighborData.key);
    return {
      done: false,
      value: [neighborData.key, neighborData.attributes]
    };
  });
}
function createNeighborIterator(type, direction, nodeData) {
  if (type !== "mixed") {
    if (type === "undirected")
      return createObjectIterator(nodeData, nodeData.undirected);
    if (typeof direction === "string")
      return createObjectIterator(nodeData, nodeData[direction]);
  }
  let iterator = import_iterator.default.empty();
  const visited = /* @__PURE__ */ new Set();
  if (type !== "undirected") {
    if (direction !== "out") {
      iterator = (0, import_chain.default)(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));
    }
    if (direction !== "in") {
      iterator = (0, import_chain.default)(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));
    }
  }
  if (type !== "directed") {
    iterator = (0, import_chain.default)(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));
  }
  return iterator;
}
function nodeHasNeighbor(graph, type, direction, node, neighbor) {
  const nodeData = graph._nodes.get(node);
  if (type !== "undirected") {
    if (direction !== "out" && typeof nodeData.in !== "undefined") {
      for (const k in nodeData.in)
        if (k === neighbor)
          return true;
    }
    if (direction !== "in" && typeof nodeData.out !== "undefined") {
      for (const k in nodeData.out)
        if (k === neighbor)
          return true;
    }
  }
  if (type !== "directed" && typeof nodeData.undirected !== "undefined") {
    for (const k in nodeData.undirected)
      if (k === neighbor)
        return true;
  }
  return false;
}
function attachNeighborArrayCreator(Class, description) {
  const {
    name,
    type,
    direction
  } = description;
  Class.prototype[name] = function(node) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return [];
    if (arguments.length === 2) {
      const node1 = "" + arguments[0], node2 = "" + arguments[1];
      if (!this._nodes.has(node1))
        throw new NotFoundGraphError(`Graph.${name}: could not find the "${node1}" node in the graph.`);
      if (!this._nodes.has(node2))
        throw new NotFoundGraphError(`Graph.${name}: could not find the "${node2}" node in the graph.`);
      return nodeHasNeighbor(
        this,
        type,
        direction,
        node1,
        node2
      );
    } else if (arguments.length === 1) {
      node = "" + node;
      const nodeData = this._nodes.get(node);
      if (typeof nodeData === "undefined")
        throw new NotFoundGraphError(`Graph.${name}: could not find the "${node}" node in the graph.`);
      const neighbors = createNeighborArrayForNode(
        type === "mixed" ? this.type : type,
        direction,
        nodeData
      );
      return neighbors;
    }
    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);
  };
}
function attachForEachNeighbor(Class, description) {
  const {
    name,
    type,
    direction
  } = description;
  const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
  Class.prototype[forEachName] = function(node, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return;
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (typeof nodeData === "undefined")
      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the "${node}" node in the graph.`);
    forEachNeighborForNode(
      type === "mixed" ? this.type : type,
      direction,
      nodeData,
      callback
    );
  };
}
function attachForEachNeighborUntil(Class, description) {
  const {
    name,
    type,
    direction
  } = description;
  const forEachUntilName = "forEach" + name[0].toUpperCase() + name.slice(1, -1) + "Until";
  Class.prototype[forEachUntilName] = function(node, callback) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return;
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (typeof nodeData === "undefined")
      throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the "${node}" node in the graph.`);
    return forEachNeighborForNodeUntil(
      type === "mixed" ? this.type : type,
      direction,
      nodeData,
      callback
    );
  };
}
function attachNeighborIteratorCreator(Class, description) {
  const {
    name,
    type,
    direction
  } = description;
  const iteratorName = name.slice(0, -1) + "Entries";
  Class.prototype[iteratorName] = function(node) {
    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
      return import_iterator.default.empty();
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (typeof nodeData === "undefined")
      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the "${node}" node in the graph.`);
    return createNeighborIterator(
      type === "mixed" ? this.type : type,
      direction,
      nodeData
    );
  };
}
function attachNeighborIterationMethods(Graph2) {
  NEIGHBORS_ITERATION.forEach((description) => {
    attachNeighborArrayCreator(Graph2, description);
    attachForEachNeighbor(Graph2, description);
    attachForEachNeighborUntil(Graph2, description);
    attachNeighborIteratorCreator(Graph2, description);
  });
}
function forEachAdjacencySimple(breakable, graph, callback) {
  const iterator = graph._nodes.values();
  const type = graph.type;
  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;
  while (step = iterator.next(), step.done !== true) {
    sourceData = step.value;
    if (type !== "undirected") {
      adj = sourceData.out;
      for (neighbor in adj) {
        edgeData = adj[neighbor];
        targetData = edgeData.target;
        shouldBreak = callback(
          sourceData.key,
          targetData.key,
          sourceData.attributes,
          targetData.attributes,
          edgeData.key,
          edgeData.attributes,
          edgeData.undirected,
          edgeData.generatedKey
        );
        if (breakable && shouldBreak)
          return true;
      }
    }
    if (type !== "directed") {
      adj = sourceData.undirected;
      for (neighbor in adj) {
        edgeData = adj[neighbor];
        targetData = edgeData.target;
        if (targetData.key !== neighbor)
          targetData = edgeData.source;
        shouldBreak = callback(
          sourceData.key,
          targetData.key,
          sourceData.attributes,
          targetData.attributes,
          edgeData.key,
          edgeData.attributes,
          edgeData.undirected,
          edgeData.generatedKey
        );
        if (breakable && shouldBreak)
          return true;
      }
    }
  }
  return false;
}
function forEachAdjacencyMulti(breakable, graph, callback) {
  const iterator = graph._nodes.values();
  const type = graph.type;
  let step, sourceData, neighbor, container, containerStep, adj, edgeData, targetData, shouldBreak;
  while (step = iterator.next(), step.done !== true) {
    sourceData = step.value;
    if (type !== "undirected") {
      adj = sourceData.out;
      for (neighbor in adj) {
        container = adj[neighbor].values();
        while (containerStep = container.next(), containerStep.done !== true) {
          edgeData = containerStep.value;
          targetData = edgeData.target;
          shouldBreak = callback(
            sourceData.key,
            targetData.key,
            sourceData.attributes,
            targetData.attributes,
            edgeData.key,
            edgeData.attributes,
            edgeData.undirected,
            edgeData.generatedKey
          );
          if (breakable && shouldBreak)
            return true;
        }
      }
    }
    if (type !== "directed") {
      adj = sourceData.undirected;
      for (neighbor in adj) {
        container = adj[neighbor].values();
        while (containerStep = container.next(), containerStep.done !== true) {
          edgeData = containerStep.value;
          targetData = edgeData.target;
          if (targetData.key !== neighbor)
            targetData = edgeData.source;
          shouldBreak = callback(
            sourceData.key,
            targetData.key,
            sourceData.attributes,
            targetData.attributes,
            edgeData.key,
            edgeData.attributes,
            edgeData.undirected,
            edgeData.generatedKey
          );
          if (breakable && shouldBreak)
            return true;
        }
      }
    }
  }
  return false;
}
function createAdjacencyIteratorSimple(graph) {
  const iterator = graph._nodes.values();
  const type = graph.type;
  let state = "outer", sourceData, neighbors, adj, offset;
  return new import_iterator.default(function next() {
    let step;
    if (state === "outer") {
      step = iterator.next();
      if (step.done === true)
        return step;
      sourceData = step.value;
      state = "directed";
      return next();
    }
    if (state === "directed") {
      if (type === "undirected") {
        state = "undirected";
        return next();
      }
      adj = sourceData.out;
      neighbors = Object.keys(sourceData.out);
      offset = 0;
      state = "inner-directed";
      return next();
    }
    if (state === "undirected") {
      if (type === "directed") {
        state = "outer";
        return next();
      }
      adj = sourceData.undirected;
      neighbors = Object.keys(sourceData.undirected);
      offset = 0;
      state = "inner-undirected";
    }
    if (offset >= neighbors.length) {
      if (state === "inner-undirected")
        state = "outer";
      else
        state = "undirected";
      return next();
    }
    const neighbor = neighbors[offset++];
    const edgeData = adj[neighbor];
    let targetData = edgeData.target;
    if (state === "inner-undirected" && targetData.key === sourceData.key)
      targetData = edgeData.source;
    return {
      done: false,
      value: [
        sourceData.key,
        targetData.key,
        sourceData.attributes,
        targetData.attributes,
        edgeData.key,
        edgeData.attributes
      ]
    };
  });
}
function createAdjacencyIteratorMulti(graph) {
  const iterator = graph._nodes.values();
  const type = graph.type;
  let state = "outer", sourceData, neighbors, container = null, adj, offset;
  return new import_iterator.default(function next() {
    let step;
    if (state === "outer") {
      step = iterator.next();
      if (step.done === true)
        return step;
      sourceData = step.value;
      state = "directed";
      return next();
    }
    if (state === "directed") {
      if (type === "undirected") {
        state = "undirected";
        return next();
      }
      adj = sourceData.out;
      neighbors = Object.keys(sourceData.out);
      offset = 0;
      state = "inner-directed";
      return next();
    }
    if (state === "undirected") {
      if (type === "directed") {
        state = "outer";
        return next();
      }
      adj = sourceData.undirected;
      neighbors = Object.keys(sourceData.undirected);
      offset = 0;
      state = "inner-undirected";
    }
    if (!container && offset >= neighbors.length) {
      if (state === "inner-undirected")
        state = "outer";
      else
        state = "undirected";
      return next();
    }
    if (!container) {
      const neighbor = neighbors[offset++];
      container = adj[neighbor].values();
      return next();
    }
    step = container.next();
    if (step.done) {
      container = null;
      return next();
    }
    const edgeData = step.value;
    let targetData = edgeData.target;
    if (state === "inner-undirected" && targetData.key === sourceData.key)
      targetData = edgeData.source;
    return {
      done: false,
      value: [
        sourceData.key,
        targetData.key,
        sourceData.attributes,
        targetData.attributes,
        edgeData.key,
        edgeData.attributes
      ]
    };
  });
}
function serializeNode(key, data) {
  const serialized = { key };
  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);
  return serialized;
}
function serializeEdge(key, data) {
  const serialized = {
    source: data.source.key,
    target: data.target.key
  };
  if (!data.generatedKey)
    serialized.key = key;
  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);
  if (data.undirected)
    serialized.undirected = true;
  return serialized;
}
function validateSerializedNode(value) {
  if (!isPlainObject(value))
    return "not-object";
  if (!("key" in value))
    return "no-key";
  if ("attributes" in value && (!isPlainObject(value.attributes) || value.attributes === null))
    return "invalid-attributes";
  return null;
}
function validateSerializedEdge(value) {
  if (!isPlainObject(value))
    return "not-object";
  if (!("source" in value))
    return "no-source";
  if (!("target" in value))
    return "no-target";
  if ("attributes" in value && (!isPlainObject(value.attributes) || value.attributes === null))
    return "invalid-attributes";
  if ("undirected" in value && typeof value.undirected !== "boolean")
    return "invalid-undirected";
  return null;
}
var TYPES = /* @__PURE__ */ new Set([
  "directed",
  "undirected",
  "mixed"
]);
var EMITTER_PROPS = /* @__PURE__ */ new Set([
  "domain",
  "_events",
  "_eventsCount",
  "_maxListeners"
]);
var EDGE_ADD_METHODS = [
  {
    name: (verb) => `${verb}Edge`,
    generateKey: true
  },
  {
    name: (verb) => `${verb}DirectedEdge`,
    generateKey: true,
    type: "directed"
  },
  {
    name: (verb) => `${verb}UndirectedEdge`,
    generateKey: true,
    type: "undirected"
  },
  {
    name: (verb) => `${verb}EdgeWithKey`
  },
  {
    name: (verb) => `${verb}DirectedEdgeWithKey`,
    type: "directed"
  },
  {
    name: (verb) => `${verb}UndirectedEdgeWithKey`,
    type: "undirected"
  }
];
var DEFAULTS = {
  allowSelfLoops: true,
  edgeKeyGenerator: null,
  multi: false,
  type: "mixed"
};
function addNode(graph, node, attributes) {
  if (attributes && !isPlainObject(attributes))
    throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got "${attributes}"`);
  node = "" + node;
  attributes = attributes || {};
  if (graph._nodes.has(node))
    throw new UsageGraphError(`Graph.addNode: the "${node}" node already exist in the graph.`);
  const data = new graph.NodeDataClass(node, attributes);
  graph._nodes.set(node, data);
  graph.emit("nodeAdded", {
    key: node,
    attributes
  });
  return data;
}
function unsafeAddNode(graph, node, attributes) {
  const data = new graph.NodeDataClass(node, attributes);
  graph._nodes.set(node, data);
  graph.emit("nodeAdded", {
    key: node,
    attributes
  });
  return data;
}
function addEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes) {
  if (!undirected && graph.type === "undirected")
    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);
  if (undirected && graph.type === "directed")
    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);
  if (attributes && !isPlainObject(attributes))
    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`);
  source = "" + source;
  target = "" + target;
  attributes = attributes || {};
  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(`Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);
  const sourceData = graph._nodes.get(source), targetData = graph._nodes.get(target);
  if (!sourceData)
    throw new NotFoundGraphError(`Graph.${name}: source node "${source}" not found.`);
  if (!targetData)
    throw new NotFoundGraphError(`Graph.${name}: target node "${target}" not found.`);
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };
  if (mustGenerateKey)
    edge = graph._edgeKeyGenerator(eventData);
  edge = "" + edge;
  if (graph._edges.has(edge))
    throw new UsageGraphError(`Graph.${name}: the "${edge}" edge already exists in the graph.`);
  if (!graph.multi && (undirected ? typeof sourceData.undirected[target] !== "undefined" : typeof sourceData.out[target] !== "undefined")) {
    throw new UsageGraphError(`Graph.${name}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);
  }
  const edgeData = new EdgeData(
    undirected,
    edge,
    mustGenerateKey,
    sourceData,
    targetData,
    attributes
  );
  graph._edges.set(edge, edgeData);
  if (source === target) {
    if (undirected) {
      sourceData.undirectedSelfLoops++;
      graph._undirectedSelfLoopCount++;
    } else {
      sourceData.directedSelfLoops++;
      graph._directedSelfLoopCount++;
    }
  } else {
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
    }
  }
  updateStructureIndex(
    graph,
    undirected,
    edgeData,
    source,
    target,
    sourceData,
    targetData
  );
  if (undirected)
    graph._undirectedSize++;
  else
    graph._directedSize++;
  eventData.key = edge;
  graph.emit("edgeAdded", eventData);
  return edge;
}
function mergeEdge(graph, name, mustGenerateKey, undirected, edge, source, target, attributes, asUpdater) {
  if (!undirected && graph.type === "undirected")
    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);
  if (undirected && graph.type === "directed")
    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);
  if (attributes) {
    if (asUpdater) {
      if (typeof attributes !== "function")
        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid updater function. Expecting a function but got "${attributes}"`);
    } else {
      if (!isPlainObject(attributes))
        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`);
    }
  }
  source = "" + source;
  target = "" + target;
  let updater;
  if (asUpdater) {
    updater = attributes;
    attributes = void 0;
  }
  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(`Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);
  let sourceData = graph._nodes.get(source), targetData = graph._nodes.get(target), edgeData;
  let alreadyExistingEdgeData;
  if (!mustGenerateKey) {
    edgeData = graph._edges.get(edge);
    if (edgeData) {
      if (edgeData.source.key !== source || edgeData.target.key !== target || undirected && (edgeData.source.key !== target || edgeData.target.key !== source)) {
        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the "${edge}" edge with "${source}" source & "${target}" target vs. ("${edgeData.source.key}", "${edgeData.target.key}").`);
      }
      alreadyExistingEdgeData = edgeData;
    }
  }
  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {
    alreadyExistingEdgeData = undirected ? sourceData.undirected[target] : sourceData.out[target];
  }
  if (alreadyExistingEdgeData) {
    if (asUpdater ? !updater : !attributes)
      return alreadyExistingEdgeData.key;
    if (asUpdater) {
      const oldAttributes = alreadyExistingEdgeData.attributes;
      alreadyExistingEdgeData.attributes = updater(oldAttributes);
      graph.emit("edgeAttributesUpdated", {
        type: "replace",
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes
      });
    } else {
      assign(alreadyExistingEdgeData.attributes, attributes);
      graph.emit("edgeAttributesUpdated", {
        type: "merge",
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes,
        data: attributes
      });
    }
    return alreadyExistingEdgeData.key;
  }
  attributes = attributes || {};
  if (asUpdater && updater)
    attributes = updater(attributes);
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };
  if (mustGenerateKey)
    edge = graph._edgeKeyGenerator(eventData);
  edge = "" + edge;
  if (graph._edges.has(edge))
    throw new UsageGraphError(`Graph.${name}: the "${edge}" edge already exists in the graph.`);
  if (!sourceData) {
    sourceData = unsafeAddNode(graph, source, {});
    if (source === target)
      targetData = sourceData;
  }
  if (!targetData) {
    targetData = unsafeAddNode(graph, target, {});
  }
  edgeData = new EdgeData(
    undirected,
    edge,
    mustGenerateKey,
    sourceData,
    targetData,
    attributes
  );
  graph._edges.set(edge, edgeData);
  if (source === target) {
    if (undirected) {
      sourceData.undirectedSelfLoops++;
      graph._undirectedSelfLoopCount++;
    } else {
      sourceData.directedSelfLoops++;
      graph._directedSelfLoopCount++;
    }
  } else {
    if (undirected) {
      sourceData.undirectedDegree++;
      targetData.undirectedDegree++;
    } else {
      sourceData.outDegree++;
      targetData.inDegree++;
    }
  }
  updateStructureIndex(
    graph,
    undirected,
    edgeData,
    source,
    target,
    sourceData,
    targetData
  );
  if (undirected)
    graph._undirectedSize++;
  else
    graph._directedSize++;
  eventData.key = edge;
  graph.emit("edgeAdded", eventData);
  return edge;
}
var Graph = class _Graph extends import_events.EventEmitter {
  constructor(options) {
    super();
    options = assign({}, DEFAULTS, options);
    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== "function")
      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got "${options.edgeKeyGenerator}".`);
    if (typeof options.multi !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options.multi}".`);
    if (!TYPES.has(options.type))
      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options.type}".`);
    if (typeof options.allowSelfLoops !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options.allowSelfLoops}".`);
    const NodeDataClass = options.type === "mixed" ? MixedNodeData : options.type === "directed" ? DirectedNodeData : UndirectedNodeData;
    privateProperty(this, "NodeDataClass", NodeDataClass);
    privateProperty(this, "_attributes", {});
    privateProperty(this, "_nodes", /* @__PURE__ */ new Map());
    privateProperty(this, "_edges", /* @__PURE__ */ new Map());
    privateProperty(this, "_directedSize", 0);
    privateProperty(this, "_undirectedSize", 0);
    privateProperty(this, "_directedSelfLoopCount", 0);
    privateProperty(this, "_undirectedSelfLoopCount", 0);
    privateProperty(this, "_edgeKeyGenerator", options.edgeKeyGenerator || incrementalId());
    privateProperty(this, "_options", options);
    EMITTER_PROPS.forEach((prop) => privateProperty(this, prop, this[prop]));
    readOnlyProperty(this, "order", () => this._nodes.size);
    readOnlyProperty(this, "size", () => this._edges.size);
    readOnlyProperty(this, "directedSize", () => this._directedSize);
    readOnlyProperty(this, "undirectedSize", () => this._undirectedSize);
    readOnlyProperty(this, "selfLoopCount", () => this._directedSelfLoopCount + this._undirectedSelfLoopCount);
    readOnlyProperty(this, "directedSelfLoopCount", () => this._directedSelfLoopCount);
    readOnlyProperty(this, "undirectedSelfLoopCount", () => this._undirectedSelfLoopCount);
    readOnlyProperty(this, "multi", this._options.multi);
    readOnlyProperty(this, "type", this._options.type);
    readOnlyProperty(this, "allowSelfLoops", this._options.allowSelfLoops);
    readOnlyProperty(this, "implementation", () => "graphology");
  }
  /**---------------------------------------------------------------------------
   * Read
   **---------------------------------------------------------------------------
   */
  /**
   * Method returning whether the given node is found in the graph.
   *
   * @param  {any}     node - The node.
   * @return {boolean}
   */
  hasNode(node) {
    return this._nodes.has("" + node);
  }
  /**
   * Method returning whether the given directed edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasDirectedEdge(source, target) {
    if (this.type === "undirected")
      return false;
    if (arguments.length === 1) {
      const edge = "" + source;
      const edgeData = this._edges.get(edge);
      return !!edgeData && !edgeData.undirected;
    } else if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const nodeData = this._nodes.get(source);
      if (!nodeData)
        return false;
      const edges = nodeData.out[target];
      if (!edges)
        return false;
      return this.multi ? !!edges.size : true;
    }
    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
  }
  /**
   * Method returning whether the given undirected edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasUndirectedEdge(source, target) {
    if (this.type === "directed")
      return false;
    if (arguments.length === 1) {
      const edge = "" + source;
      const edgeData = this._edges.get(edge);
      return !!edgeData && edgeData.undirected;
    } else if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const nodeData = this._nodes.get(source);
      if (!nodeData)
        return false;
      const edges = nodeData.undirected[target];
      if (!edges)
        return false;
      return this.multi ? !!edges.size : true;
    }
    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
  }
  /**
   * Method returning whether the given edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasEdge(source, target) {
    if (arguments.length === 1) {
      const edge = "" + source;
      return this._edges.has(edge);
    } else if (arguments.length === 2) {
      source = "" + source;
      target = "" + target;
      const nodeData = this._nodes.get(source);
      if (!nodeData)
        return false;
      let edges = typeof nodeData.out !== "undefined" && nodeData.out[target];
      if (!edges)
        edges = typeof nodeData.undirected !== "undefined" && nodeData.undirected[target];
      if (!edges)
        return false;
      return this.multi ? !!edges.size : true;
    }
    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);
  }
  /**
   * Method returning the edge matching source & target in a directed fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  directedEdge(source, target) {
    if (this.type === "undirected")
      return;
    source = "" + source;
    target = "" + target;
    if (this.multi)
      throw new UsageGraphError("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");
    const sourceData = this._nodes.get(source);
    if (!sourceData)
      throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${source}" source node in the graph.`);
    if (!this._nodes.has(target))
      throw new NotFoundGraphError(`Graph.directedEdge: could not find the "${target}" target node in the graph.`);
    const edgeData = sourceData.out && sourceData.out[target] || void 0;
    if (edgeData)
      return edgeData.key;
  }
  /**
   * Method returning the edge matching source & target in a undirected fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  undirectedEdge(source, target) {
    if (this.type === "directed")
      return;
    source = "" + source;
    target = "" + target;
    if (this.multi)
      throw new UsageGraphError("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");
    const sourceData = this._nodes.get(source);
    if (!sourceData)
      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${source}" source node in the graph.`);
    if (!this._nodes.has(target))
      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the "${target}" target node in the graph.`);
    const edgeData = sourceData.undirected && sourceData.undirected[target] || void 0;
    if (edgeData)
      return edgeData.key;
  }
  /**
   * Method returning the edge matching source & target in a mixed fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  edge(source, target) {
    if (this.multi)
      throw new UsageGraphError("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");
    source = "" + source;
    target = "" + target;
    const sourceData = this._nodes.get(source);
    if (!sourceData)
      throw new NotFoundGraphError(`Graph.edge: could not find the "${source}" source node in the graph.`);
    if (!this._nodes.has(target))
      throw new NotFoundGraphError(`Graph.edge: could not find the "${target}" target node in the graph.`);
    const edgeData = sourceData.out && sourceData.out[target] || sourceData.undirected && sourceData.undirected[target] || void 0;
    if (edgeData)
      return edgeData.key;
  }
  /**
   * Method returning the given node's in degree.
   *
   * @param  {any}     node      - The node's key.
   * @param  {boolean} allowSelfLoops - Count self-loops?
   * @return {number}            - The node's in degree.
   *
   * @throws {Error} - Will throw if the selfLoops arg is not boolean.
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inDegree(node, selfLoops = true) {
    if (typeof selfLoops !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.inDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    const loops = selfLoops ? nodeData.directedSelfLoops : 0;
    return nodeData.inDegree + loops;
  }
  /**
   * Method returning the given node's out degree.
   *
   * @param  {any}     node      - The node's key.
   * @param  {boolean} selfLoops - Count self-loops?
   * @return {number}            - The node's out degree.
   *
   * @throws {Error} - Will throw if the selfLoops arg is not boolean.
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outDegree(node, selfLoops = true) {
    if (typeof selfLoops !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.outDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    const loops = selfLoops ? nodeData.directedSelfLoops : 0;
    return nodeData.outDegree + loops;
  }
  /**
   * Method returning the given node's directed degree.
   *
   * @param  {any}     node      - The node's key.
   * @param  {boolean} selfLoops - Count self-loops?
   * @return {number}            - The node's directed degree.
   *
   * @throws {Error} - Will throw if the selfLoops arg is not boolean.
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  directedDegree(node, selfLoops = true) {
    if (typeof selfLoops !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.directedDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "undirected")
      return 0;
    const loops = selfLoops ? nodeData.directedSelfLoops : 0;
    const inDegree = nodeData.inDegree + loops;
    const outDegree = nodeData.outDegree + loops;
    return inDegree + outDegree;
  }
  /**
   * Method returning the given node's undirected degree.
   *
   * @param  {any}     node      - The node's key.
   * @param  {boolean} selfLoops - Count self-loops?
   * @return {number}            - The node's undirected degree.
   *
   * @throws {Error} - Will throw if the selfLoops arg is not boolean.
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  undirectedDegree(node, selfLoops = true) {
    if (typeof selfLoops !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the "${node}" node in the graph.`);
    if (this.type === "directed")
      return 0;
    const loops = selfLoops ? nodeData.undirectedSelfLoops : 0;
    return nodeData.undirectedDegree + loops * 2;
  }
  /**
   * Method returning the given node's degree.
   *
   * @param  {any}     node      - The node's key.
   * @param  {boolean} selfLoops - Count self-loops?
   * @return {number}            - The node's degree.
   *
   * @throws {Error} - Will throw if the selfLoops arg is not boolean.
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  degree(node, selfLoops = true) {
    if (typeof selfLoops !== "boolean")
      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got "${selfLoops}" for the second parameter (allowing self-loops to be counted).`);
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.degree: could not find the "${node}" node in the graph.`);
    let degree = 0;
    let loops = 0;
    if (this.type !== "directed") {
      if (selfLoops)
        loops = nodeData.undirectedSelfLoops;
      degree += nodeData.undirectedDegree + loops * 2;
    }
    if (this.type !== "undirected") {
      if (selfLoops)
        loops = nodeData.directedSelfLoops;
      degree += nodeData.inDegree + nodeData.outDegree + loops * 2;
    }
    return degree;
  }
  /**
   * Method returning the given edge's source.
   *
   * @param  {any} edge - The edge's key.
   * @return {any}      - The edge's source.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  source(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.source: could not find the "${edge}" edge in the graph.`);
    return data.source.key;
  }
  /**
   * Method returning the given edge's target.
   *
   * @param  {any} edge - The edge's key.
   * @return {any}      - The edge's target.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  target(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.target: could not find the "${edge}" edge in the graph.`);
    return data.target.key;
  }
  /**
   * Method returning the given edge's extremities.
   *
   * @param  {any}   edge - The edge's key.
   * @return {array}      - The edge's extremities.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  extremities(edge) {
    edge = "" + edge;
    const edgeData = this._edges.get(edge);
    if (!edgeData)
      throw new NotFoundGraphError(`Graph.extremities: could not find the "${edge}" edge in the graph.`);
    return [
      edgeData.source.key,
      edgeData.target.key
    ];
  }
  /**
   * Given a node & an edge, returns the other extremity of the edge.
   *
   * @param  {any}   node - The node's key.
   * @param  {any}   edge - The edge's key.
   * @return {any}        - The related node.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph or if the
   *                   edge & node are not related.
   */
  opposite(node, edge) {
    node = "" + node;
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.opposite: could not find the "${edge}" edge in the graph.`);
    const source = data.source.key, target = data.target.key;
    if (node !== source && node !== target)
      throw new NotFoundGraphError(`Graph.opposite: the "${node}" node is not attached to the "${edge}" edge (${source}, ${target}).`);
    return node === source ? target : source;
  }
  /**
   * Returns whether the given edge has the given node as extremity.
   *
   * @param  {any}     edge - The edge's key.
   * @param  {any}     node - The node's key.
   * @return {boolean}      - The related node.
   *
   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
   */
  hasExtremity(edge, node) {
    edge = "" + edge;
    node = "" + node;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.hasExtremity: could not find the "${edge}" edge in the graph.`);
    return data.source.key === node || data.target.key === node;
  }
  /**
   * Method returning whether the given edge is undirected.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isUndirected(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.isUndirected: could not find the "${edge}" edge in the graph.`);
    return data.undirected;
  }
  /**
   * Method returning whether the given edge is directed.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isDirected(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.isDirected: could not find the "${edge}" edge in the graph.`);
    return !data.undirected;
  }
  /**
   * Method returning whether the given edge is a self loop.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isSelfLoop(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.isSelfLoop: could not find the "${edge}" edge in the graph.`);
    return data.source === data.target;
  }
  /**
   * Method returning whether the given edge has a generated key.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  hasGeneratedKey(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.hasGeneratedKey: could not find the "${edge}" edge in the graph.`);
    return data.generatedKey;
  }
  /**---------------------------------------------------------------------------
   * Mutation
   **---------------------------------------------------------------------------
   */
  /**
   * Method used to add a node to the graph.
   *
   * @param  {any}    node         - The node.
   * @param  {object} [attributes] - Optional attributes.
   * @return {any}                 - The node.
   *
   * @throws {Error} - Will throw if the given node already exist.
   * @throws {Error} - Will throw if the given attributes are not an object.
   */
  addNode(node, attributes) {
    const nodeData = addNode(this, node, attributes);
    return nodeData.key;
  }
  /**
   * Method used to merge a node into the graph.
   *
   * @param  {any}    node         - The node.
   * @param  {object} [attributes] - Optional attributes.
   * @return {any}                 - The node.
   */
  mergeNode(node, attributes) {
    if (attributes && !isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got "${attributes}"`);
    node = "" + node;
    attributes = attributes || {};
    let data = this._nodes.get(node);
    if (data) {
      if (attributes) {
        assign(data.attributes, attributes);
        this.emit("nodeAttributesUpdated", {
          type: "merge",
          key: node,
          attributes: data.attributes,
          data: attributes
        });
      }
      return node;
    }
    data = new this.NodeDataClass(node, attributes);
    this._nodes.set(node, data);
    this.emit("nodeAdded", {
      key: node,
      attributes
    });
    return node;
  }
  /**
   * Method used to add a node if it does not exist in the graph or else to
   * update its attributes using a function.
   *
   * @param  {any}      node      - The node.
   * @param  {function} [updater] - Optional updater function.
   * @return {any}                - The node.
   */
  updateNode(node, updater) {
    if (updater && typeof updater !== "function")
      throw new InvalidArgumentsGraphError(`Graph.updateNode: invalid updater function. Expecting a function but got "${updater}"`);
    node = "" + node;
    let data = this._nodes.get(node);
    if (data) {
      if (updater) {
        const oldAttributes = data.attributes;
        data.attributes = updater(oldAttributes);
        this.emit("nodeAttributesUpdated", {
          type: "replace",
          key: node,
          attributes: data.attributes
        });
      }
      return node;
    }
    const attributes = updater ? updater({}) : {};
    data = new this.NodeDataClass(node, attributes);
    this._nodes.set(node, data);
    this.emit("nodeAdded", {
      key: node,
      attributes
    });
    return node;
  }
  /**
   * Method used to drop a single node & all its attached edges from the graph.
   *
   * @param  {any}    node - The node.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the node doesn't exist.
   */
  dropNode(node) {
    node = "" + node;
    const nodeData = this._nodes.get(node);
    if (!nodeData)
      throw new NotFoundGraphError(`Graph.dropNode: could not find the "${node}" node in the graph.`);
    this.forEachEdge(node, (edge) => {
      this.dropEdge(edge);
    });
    this._nodes.delete(node);
    this.emit("nodeDropped", {
      key: node,
      attributes: nodeData.attributes
    });
  }
  /**
   * Method used to drop a single edge from the graph.
   *
   * Arity 1:
   * @param  {any}    edge - The edge.
   *
   * Arity 2:
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   *
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the edge doesn't exist.
   */
  dropEdge(edge) {
    let edgeData;
    if (arguments.length > 1) {
      const source = "" + arguments[0], target = "" + arguments[1];
      edgeData = getMatchingEdge(this, source, target, this.type);
      if (!edgeData)
        throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`);
    } else {
      edge = "" + edge;
      edgeData = this._edges.get(edge);
      if (!edgeData)
        throw new NotFoundGraphError(`Graph.dropEdge: could not find the "${edge}" edge in the graph.`);
    }
    this._edges.delete(edgeData.key);
    const {
      source: sourceData,
      target: targetData,
      attributes
    } = edgeData;
    const undirected = edgeData.undirected;
    if (sourceData === targetData) {
      if (undirected) {
        sourceData.undirectedSelfLoops--;
        this._undirectedSelfLoopCount--;
      } else {
        sourceData.directedSelfLoops--;
        this._directedSelfLoopCount--;
      }
    } else {
      if (undirected) {
        sourceData.undirectedDegree--;
        targetData.undirectedDegree--;
      } else {
        sourceData.outDegree--;
        targetData.inDegree--;
      }
    }
    clearEdgeFromStructureIndex(this, undirected, edgeData);
    if (undirected)
      this._undirectedSize--;
    else
      this._directedSize--;
    this.emit("edgeDropped", {
      key: edge,
      attributes,
      source: sourceData.key,
      target: targetData.key,
      undirected
    });
    return this;
  }
  /**
   * Method used to remove every edge & every node from the graph.
   *
   * @return {Graph}
   */
  clear() {
    this._edges.clear();
    this._nodes.clear();
    this.emit("cleared");
  }
  /**
   * Method used to remove every edge from the graph.
   *
   * @return {Graph}
   */
  clearEdges() {
    this._edges.clear();
    this.clearIndex();
    this.emit("edgesCleared");
  }
  /**---------------------------------------------------------------------------
   * Attributes-related methods
   **---------------------------------------------------------------------------
   */
  /**
   * Method returning the desired graph's attribute.
   *
   * @param  {string} name - Name of the attribute.
   * @return {any}
   */
  getAttribute(name) {
    return this._attributes[name];
  }
  /**
   * Method returning the graph's attributes.
   *
   * @return {object}
   */
  getAttributes() {
    return this._attributes;
  }
  /**
   * Method returning whether the graph has the desired attribute.
   *
   * @param  {string}  name - Name of the attribute.
   * @return {boolean}
   */
  hasAttribute(name) {
    return this._attributes.hasOwnProperty(name);
  }
  /**
   * Method setting a value for the desired graph's attribute.
   *
   * @param  {string}  name  - Name of the attribute.
   * @param  {any}     value - Value for the attribute.
   * @return {Graph}
   */
  setAttribute(name, value) {
    this._attributes[name] = value;
    this.emit("attributesUpdated", {
      type: "set",
      attributes: this._attributes,
      name
    });
    return this;
  }
  /**
   * Method using a function to update the desired graph's attribute's value.
   *
   * @param  {string}   name    - Name of the attribute.
   * @param  {function} updater - Function use to update the attribute's value.
   * @return {Graph}
   */
  updateAttribute(name, updater) {
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateAttribute: updater should be a function.");
    const value = this._attributes[name];
    this._attributes[name] = updater(value);
    this.emit("attributesUpdated", {
      type: "set",
      attributes: this._attributes,
      name
    });
    return this;
  }
  /**
   * Method removing the desired graph's attribute.
   *
   * @param  {string} name  - Name of the attribute.
   * @return {Graph}
   */
  removeAttribute(name) {
    delete this._attributes[name];
    this.emit("attributesUpdated", {
      type: "remove",
      attributes: this._attributes,
      name
    });
    return this;
  }
  /**
   * Method replacing the graph's attributes.
   *
   * @param  {object} attributes - New attributes.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given attributes are not a plain object.
   */
  replaceAttributes(attributes) {
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError("Graph.replaceAttributes: provided attributes are not a plain object.");
    this._attributes = attributes;
    this.emit("attributesUpdated", {
      type: "replace",
      attributes: this._attributes
    });
    return this;
  }
  /**
   * Method merging the graph's attributes.
   *
   * @param  {object} attributes - Attributes to merge.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given attributes are not a plain object.
   */
  mergeAttributes(attributes) {
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError("Graph.mergeAttributes: provided attributes are not a plain object.");
    assign(this._attributes, attributes);
    this.emit("attributesUpdated", {
      type: "merge",
      attributes: this._attributes,
      data: attributes
    });
    return this;
  }
  /**
   * Method returning the desired attribute for the given node.
   *
   * @param  {any}    node - Target node.
   * @param  {string} name - Name of the attribute to get.
   * @return {any}
   *
   * @throws {Error} - Will throw if the node is not found.
   */
  getNodeAttribute(node, name) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the "${node}" node in the graph.`);
    return data.attributes[name];
  }
  /**
   * Method returning the attributes for the given node.
   *
   * @param  {any}    node - Target node.
   * @return {object}
   *
   * @throws {Error} - Will throw if the node is not found.
   */
  getNodeAttributes(node) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the "${node}" node in the graph.`);
    return data.attributes;
  }
  /**
   * Method checking whether the given attribute exists for the given node.
   *
   * @param  {any}    node - Target node.
   * @param  {string} name - Name of the attribute to check.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node is not found.
   */
  hasNodeAttribute(node, name) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the "${node}" node in the graph.`);
    return data.attributes.hasOwnProperty(name);
  }
  /**
   * Method checking setting the desired attribute for the given node.
   *
   * @param  {any}    node  - Target node.
   * @param  {string} name  - Name of the attribute to set.
   * @param  {any}    value - Value for the attribute.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if less than 3 arguments are passed.
   * @throws {Error} - Will throw if the node is not found.
   */
  setNodeAttribute(node, name, value) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the "${node}" node in the graph.`);
    if (arguments.length < 3)
      throw new InvalidArgumentsGraphError("Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.");
    data.attributes[name] = value;
    this.emit("nodeAttributesUpdated", {
      key: node,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  }
  /**
   * Method checking setting the desired attribute for the given node.
   *
   * @param  {any}      node    - Target node.
   * @param  {string}   name    - Name of the attribute to set.
   * @param  {function} updater - Function that will update the attribute.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if less than 3 arguments are passed.
   * @throws {Error} - Will throw if updater is not a function.
   * @throws {Error} - Will throw if the node is not found.
   */
  updateNodeAttribute(node, name, updater) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the "${node}" node in the graph.`);
    if (arguments.length < 3)
      throw new InvalidArgumentsGraphError("Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute's name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.");
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateAttribute: updater should be a function.");
    const attributes = data.attributes;
    const value = updater(attributes[name]);
    attributes[name] = value;
    this.emit("nodeAttributesUpdated", {
      key: node,
      type: "set",
      attributes: data.attributes,
      name
    });
    return this;
  }
  /**
   * Method removing the desired attribute for the given node.
   *
   * @param  {any}    node  - Target node.
   * @param  {string} name  - Name of the attribute to remove.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the node is not found.
   */
  removeNodeAttribute(node, name) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.removeNodeAttribute: could not find the "${node}" node in the graph.`);
    delete data.attributes[name];
    this.emit("nodeAttributesUpdated", {
      key: node,
      type: "remove",
      attributes: data.attributes,
      name
    });
    return this;
  }
  /**
   * Method completely replacing the attributes of the given node.
   *
   * @param  {any}    node       - Target node.
   * @param  {object} attributes - New attributes.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the node is not found.
   * @throws {Error} - Will throw if the given attributes is not a plain object.
   */
  replaceNodeAttributes(node, attributes) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the "${node}" node in the graph.`);
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError("Graph.replaceNodeAttributes: provided attributes are not a plain object.");
    data.attributes = attributes;
    this.emit("nodeAttributesUpdated", {
      key: node,
      type: "replace",
      attributes: data.attributes
    });
    return this;
  }
  /**
   * Method merging the attributes of the given node with the provided ones.
   *
   * @param  {any}    node       - Target node.
   * @param  {object} attributes - Attributes to merge.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the node is not found.
   * @throws {Error} - Will throw if the given attributes is not a plain object.
   */
  mergeNodeAttributes(node, attributes) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the "${node}" node in the graph.`);
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError("Graph.mergeNodeAttributes: provided attributes are not a plain object.");
    assign(data.attributes, attributes);
    this.emit("nodeAttributesUpdated", {
      key: node,
      type: "merge",
      attributes: data.attributes,
      data: attributes
    });
    return this;
  }
  /**
   * Method used to update each node's attributes using the given function.
   *
   * @param {function}  updater - Updater function to use.
   * @param {object}    [hints] - Optional hints.
   */
  updateEachNodeAttributes(updater, hints) {
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateEachNodeAttributes: expecting an updater function.");
    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
    const iterator = this._nodes.values();
    let step, nodeData;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      nodeData.attributes = updater(nodeData.key, nodeData.attributes);
    }
    this.emit("eachNodeAttributesUpdated", {
      hints: hints ? hints : null
    });
  }
  /**
   * Method used to update each edge's attributes using the given function.
   *
   * @param {function}  updater - Updater function to use.
   * @param {object}    [hints] - Optional hints.
   */
  updateEachEdgeAttributes(updater, hints) {
    if (typeof updater !== "function")
      throw new InvalidArgumentsGraphError("Graph.updateEachEdgeAttributes: expecting an updater function.");
    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
    const iterator = this._edges.values();
    let step, edgeData;
    while (step = iterator.next(), step.done !== true) {
      edgeData = step.value;
      edgeData.attributes = updater(edgeData.key, edgeData.attributes);
    }
    this.emit("eachEdgeAttributesUpdated", {
      hints: hints ? hints : null
    });
  }
  /**---------------------------------------------------------------------------
   * Iteration-related methods
   **---------------------------------------------------------------------------
   */
  /**
   * Method iterating over the graph's adjacency using the given callback.
   *
   * @param  {function}  callback - Callback to use.
   */
  forEach(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEach: expecting a callback.");
    if (this.multi)
      forEachAdjacencyMulti(false, this, callback);
    else
      forEachAdjacencySimple(false, this, callback);
  }
  /**
   * Method iterating over the graph's adjacency using the given callback until
   * it returns a truthy value to stop iteration.
   *
   * @param  {function}  callback - Callback to use.
   */
  forEachUntil(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEach: expecting a callback.");
    if (this.multi)
      return forEachAdjacencyMulti(true, this, callback);
    return forEachAdjacencySimple(true, this, callback);
  }
  /**
   * Method returning an iterator over the graph's adjacency.
   *
   * @return {Iterator}
   */
  adjacency() {
    if (this.multi)
      return createAdjacencyIteratorMulti(this);
    return createAdjacencyIteratorSimple(this);
  }
  /**
   * Method returning the list of the graph's nodes.
   *
   * @return {array} - The nodes.
   */
  nodes() {
    if (typeof Array.from === "function")
      return Array.from(this._nodes.keys());
    return (0, import_take.default)(this._nodes.keys(), this._nodes.size);
  }
  /**
   * Method iterating over the graph's nodes using the given callback.
   *
   * @param  {function}  callback - Callback (key, attributes, index).
   */
  forEachNode(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEachNode: expecting a callback.");
    this._nodes.forEach((data, key) => {
      callback(key, data.attributes);
    });
  }
  /**
   * Method iterating over the graph's nodes using the given callback until
   * it returns a truthy value to stop iteration.
   *
   * @param  {function}  callback - Callback (key, attributes, index).
   */
  forEachNodeUntil(callback) {
    if (typeof callback !== "function")
      throw new InvalidArgumentsGraphError("Graph.forEachNode: expecting a callback.");
    const iterator = this._nodes.values();
    let step, nodeData, shouldBreak;
    while (step = iterator.next(), step.done !== true) {
      nodeData = step.value;
      shouldBreak = callback(nodeData.key, nodeData.attributes);
      if (shouldBreak)
        return true;
    }
    return false;
  }
  /**
   * Method returning an iterator over the graph's node entries.
   *
   * @return {Iterator}
   */
  nodeEntries() {
    const iterator = this._nodes.values();
    return new import_iterator.default(() => {
      const step = iterator.next();
      if (step.done)
        return step;
      const data = step.value;
      return { value: [data.key, data.attributes], done: false };
    });
  }
  /**---------------------------------------------------------------------------
   * Serialization
   **---------------------------------------------------------------------------
   */
  /**
   * Method exporting the target node.
   *
   * @param  {any}   node - Target node.
   * @return {array}      - The serialized node.
   *
   * @throws {Error} - Will throw if the node is not found.
   */
  exportNode(node) {
    node = "" + node;
    const data = this._nodes.get(node);
    if (!data)
      throw new NotFoundGraphError(`Graph.exportNode: could not find the "${node}" node in the graph.`);
    return serializeNode(node, data);
  }
  /**
   * Method exporting the target edge.
   *
   * @param  {any}   edge - Target edge.
   * @return {array}      - The serialized edge.
   *
   * @throws {Error} - Will throw if the edge is not found.
   */
  exportEdge(edge) {
    edge = "" + edge;
    const data = this._edges.get(edge);
    if (!data)
      throw new NotFoundGraphError(`Graph.exportEdge: could not find the "${edge}" edge in the graph.`);
    return serializeEdge(edge, data);
  }
  /**
   * Method used to export the whole graph.
   *
   * @return {object} - The serialized graph.
   */
  export() {
    const nodes = new Array(this._nodes.size);
    let i = 0;
    this._nodes.forEach((data, key) => {
      nodes[i++] = serializeNode(key, data);
    });
    const edges = new Array(this._edges.size);
    i = 0;
    this._edges.forEach((data, key) => {
      edges[i++] = serializeEdge(key, data);
    });
    return {
      attributes: this.getAttributes(),
      nodes,
      edges,
      options: {
        type: this.type,
        multi: this.multi,
        allowSelfLoops: this.allowSelfLoops
      }
    };
  }
  /**
   * Method used to import a serialized node.
   *
   * @param  {object} data   - The serialized node.
   * @param  {boolean} merge - Whether to merge the given node.
   * @return {Graph}         - Returns itself for chaining.
   */
  importNode(data, merge2 = false) {
    const error = validateSerializedNode(data);
    if (error) {
      if (error === "not-object")
        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
      if (error === "no-key")
        throw new InvalidArgumentsGraphError("Graph.importNode: no key provided.");
      if (error === "invalid-attributes")
        throw new InvalidArgumentsGraphError("Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.");
    }
    const { key, attributes = {} } = data;
    if (merge2)
      this.mergeNode(key, attributes);
    else
      this.addNode(key, attributes);
    return this;
  }
  /**
   * Method used to import a serialized edge.
   *
   * @param  {object}  data  - The serialized edge.
   * @param  {boolean} merge - Whether to merge the given edge.
   * @return {Graph}         - Returns itself for chaining.
   */
  importEdge(data, merge2 = false) {
    const error = validateSerializedEdge(data);
    if (error) {
      if (error === "not-object")
        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
      if (error === "no-source")
        throw new InvalidArgumentsGraphError("Graph.importEdge: missing souce.");
      if (error === "no-target")
        throw new InvalidArgumentsGraphError("Graph.importEdge: missing target.");
      if (error === "invalid-attributes")
        throw new InvalidArgumentsGraphError("Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.");
      if (error === "invalid-undirected")
        throw new InvalidArgumentsGraphError("Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.");
    }
    const {
      source,
      target,
      attributes = {},
      undirected = false
    } = data;
    let method;
    if ("key" in data) {
      method = merge2 ? undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey;
      method.call(
        this,
        data.key,
        source,
        target,
        attributes
      );
    } else {
      method = merge2 ? undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge : undirected ? this.addUndirectedEdge : this.addDirectedEdge;
      method.call(
        this,
        source,
        target,
        attributes
      );
    }
    return this;
  }
  /**
   * Method used to import a serialized graph.
   *
   * @param  {object|Graph} data  - The serialized graph.
   * @param  {boolean}      merge - Whether to merge data.
   * @return {Graph}              - Returns itself for chaining.
   */
  import(data, merge2 = false) {
    if (isGraph(data)) {
      this.import(data.export(), merge2);
      return this;
    }
    if (!isPlainObject(data))
      throw new InvalidArgumentsGraphError("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");
    if (data.attributes) {
      if (!isPlainObject(data.attributes))
        throw new InvalidArgumentsGraphError("Graph.import: invalid attributes. Expecting a plain object.");
      if (merge2)
        this.mergeAttributes(data.attributes);
      else
        this.replaceAttributes(data.attributes);
    }
    let i, l, list;
    if (data.nodes) {
      list = data.nodes;
      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError("Graph.import: invalid nodes. Expecting an array.");
      for (i = 0, l = list.length; i < l; i++)
        this.importNode(list[i], merge2);
    }
    if (data.edges) {
      list = data.edges;
      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError("Graph.import: invalid edges. Expecting an array.");
      for (i = 0, l = list.length; i < l; i++)
        this.importEdge(list[i], merge2);
    }
    return this;
  }
  /**---------------------------------------------------------------------------
   * Utils
   **---------------------------------------------------------------------------
   */
  /**
   * Method returning a null copy of the graph, i.e. a graph without nodes
   * & edges but with the exact same options.
   *
   * @param  {object} options - Options to merge with the current ones.
   * @return {Graph}          - The null copy.
   */
  nullCopy(options) {
    return new _Graph(assign({}, this._options, options));
  }
  /**
   * Method returning an empty copy of the graph, i.e. a graph without edges but
   * with the exact same options.
   *
   * @param  {object} options - Options to merge with the current ones.
   * @return {Graph}          - The empty copy.
   */
  emptyCopy(options) {
    const graph = this.nullCopy(options);
    this._nodes.forEach((nodeData, key) => {
      const attributes = assign({}, nodeData.attributes);
      nodeData = new graph.NodeDataClass(key, attributes);
      graph._nodes.set(key, nodeData);
    });
    return graph;
  }
  /**
   * Method returning an exact copy of the graph.
   *
   * @return {Graph} - The copy.
   */
  copy() {
    const graph = new _Graph(this._options);
    graph.import(this);
    return graph;
  }
  /**
   * Method upgrading the graph to a mixed one.
   *
   * @return {Graph} - The copy.
   */
  upgradeToMixed() {
    if (this.type === "mixed")
      return this;
    this._nodes.forEach((data) => data.upgradeToMixed());
    this._options.type = "mixed";
    readOnlyProperty(this, "type", this._options.type);
    privateProperty(this, "NodeDataClass", MixedNodeData);
    return this;
  }
  /**
   * Method upgrading the graph to a multi one.
   *
   * @return {Graph} - The copy.
   */
  upgradeToMulti() {
    if (this.multi)
      return this;
    this._options.multi = true;
    readOnlyProperty(this, "multi", true);
    upgradeStructureIndexToMulti(this);
    return this;
  }
  /**---------------------------------------------------------------------------
   * Indexes-related methods
   **---------------------------------------------------------------------------
   */
  /**
   * Method used to clear the desired index to clear memory.
   *
   * @return {Graph}       - Returns itself for chaining.
   */
  clearIndex() {
    clearStructureIndex(this);
    return this;
  }
  /**---------------------------------------------------------------------------
   * Known methods
   **---------------------------------------------------------------------------
   */
  /**
   * Method used by JavaScript to perform JSON serialization.
   *
   * @return {object} - The serialized graph.
   */
  toJSON() {
    return this.export();
  }
  /**
   * Method returning [object Graph].
   */
  toString() {
    return "[object Graph]";
  }
  /**
   * Method used internally by node's console to display a custom object.
   *
   * @return {object} - Formatted object representation of the graph.
   */
  inspect() {
    const nodes = {};
    this._nodes.forEach((data, key) => {
      nodes[key] = data.attributes;
    });
    const edges = {}, multiIndex = {};
    this._edges.forEach((data, key) => {
      const direction = data.undirected ? "--" : "->";
      let label = "";
      const desc = `(${data.source.key})${direction}(${data.target.key})`;
      if (!data.generatedKey) {
        label += `[${key}]: `;
      } else if (this.multi) {
        if (typeof multiIndex[desc] === "undefined") {
          multiIndex[desc] = 0;
        } else {
          multiIndex[desc]++;
        }
        label += `${multiIndex[desc]}. `;
      }
      label += desc;
      edges[label] = data.attributes;
    });
    const dummy = {};
    for (const k in this) {
      if (this.hasOwnProperty(k) && !EMITTER_PROPS.has(k) && typeof this[k] !== "function")
        dummy[k] = this[k];
    }
    dummy.attributes = this._attributes;
    dummy.nodes = nodes;
    dummy.edges = edges;
    privateProperty(dummy, "constructor", this.constructor);
    return dummy;
  }
};
if (typeof Symbol !== "undefined")
  Graph.prototype[Symbol.for("nodejs.util.inspect.custom")] = Graph.prototype.inspect;
EDGE_ADD_METHODS.forEach((method) => {
  ["add", "merge", "update"].forEach((verb) => {
    const name = method.name(verb), fn = verb === "add" ? addEdge : mergeEdge;
    if (method.generateKey) {
      Graph.prototype[name] = function(source, target, attributes) {
        return fn(
          this,
          name,
          true,
          (method.type || this.type) === "undirected",
          null,
          source,
          target,
          attributes,
          verb === "update"
        );
      };
    } else {
      Graph.prototype[name] = function(edge, source, target, attributes) {
        return fn(
          this,
          name,
          false,
          (method.type || this.type) === "undirected",
          edge,
          source,
          target,
          attributes,
          verb === "update"
        );
      };
    }
  });
});
if (typeof Symbol !== "undefined")
  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;
attachAttributesMethods(Graph);
attachEdgeIterationMethods(Graph);
attachNeighborIterationMethods(Graph);
var DirectedGraph = class extends Graph {
  constructor(options) {
    const finalOptions = assign({ type: "directed" }, options);
    if ("multi" in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
    if (finalOptions.type !== "directed")
      throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
};
var UndirectedGraph = class extends Graph {
  constructor(options) {
    const finalOptions = assign({ type: "undirected" }, options);
    if ("multi" in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
    if (finalOptions.type !== "undirected")
      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
};
var MultiGraph = class extends Graph {
  constructor(options) {
    const finalOptions = assign({ multi: true }, options);
    if ("multi" in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");
    super(finalOptions);
  }
};
var MultiDirectedGraph = class extends Graph {
  constructor(options) {
    const finalOptions = assign({ type: "directed", multi: true }, options);
    if ("multi" in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
    if (finalOptions.type !== "directed")
      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
};
var MultiUndirectedGraph = class extends Graph {
  constructor(options) {
    const finalOptions = assign({ type: "undirected", multi: true }, options);
    if ("multi" in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
    if (finalOptions.type !== "undirected")
      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent "' + finalOptions.type + '" type in given options!');
    super(finalOptions);
  }
};
function attachStaticFromMethod(Class) {
  Class.from = function(data, options) {
    const finalOptions = assign({}, data.options, options);
    const instance = new Class(finalOptions);
    instance.import(data);
    return instance;
  };
}
attachStaticFromMethod(Graph);
attachStaticFromMethod(DirectedGraph);
attachStaticFromMethod(UndirectedGraph);
attachStaticFromMethod(MultiGraph);
attachStaticFromMethod(MultiDirectedGraph);
attachStaticFromMethod(MultiUndirectedGraph);
Graph.Graph = Graph;
Graph.DirectedGraph = DirectedGraph;
Graph.UndirectedGraph = UndirectedGraph;
Graph.MultiGraph = MultiGraph;
Graph.MultiDirectedGraph = MultiDirectedGraph;
Graph.MultiUndirectedGraph = MultiUndirectedGraph;
Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
Graph.NotFoundGraphError = NotFoundGraphError;
Graph.UsageGraphError = UsageGraphError;
export {
  DirectedGraph,
  Graph,
  InvalidArgumentsGraphError,
  MultiDirectedGraph,
  MultiGraph,
  MultiUndirectedGraph,
  NotFoundGraphError,
  UndirectedGraph,
  UsageGraphError,
  Graph as default
};
//# sourceMappingURL=graphology.js.map
