{
  "version": 3,
  "sources": ["../../graphology-utils/is-graph-constructor.js", "../../graphology-gexf/common/helpers.js", "../../graphology-gexf/browser/parser.js", "../../graphology-utils/is-graph.js", "../../xml-writer/lib/xml-writer.js", "../../xml-writer/index.js", "../../graphology-gexf/common/writer.js", "../../graphology-gexf/browser/index.js"],
  "sourcesContent": ["/**\n * Graphology isGraphConstructor\n * ==============================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology constructor.\n */\n\n/**\n * Checking the value is a graphology constructor.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraphConstructor(value) {\n  return (\n    value !== null &&\n    typeof value === 'function' &&\n    typeof value.prototype === 'object' &&\n    typeof value.prototype.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.prototype.dropNode === 'function'\n  );\n};\n", "/**\n * Graphology Common GEXF Helpers\n * ===============================\n *\n * Miscellaneous helpers used by both instance of the code.\n */\n\n/**\n * Function used to cast a string value to the desired type.\n *\n * @param  {string} type - Value type.\n * @param  {string} type - String value.\n * @return {any}         - Parsed type.\n */\nexports.cast = function(type, value) {\n  switch (type) {\n    case 'boolean':\n      value = (value === 'true');\n      break;\n\n    case 'integer':\n    case 'long':\n    case 'float':\n    case 'double':\n      value = +value;\n      break;\n\n    case 'liststring':\n      value = value ? value.split('|') : [];\n      break;\n\n    default:\n  }\n\n  return value;\n};\n", "/* eslint no-self-compare: 0 */\n/**\n * Graphology Browser GEXF Parser\n * ===============================\n *\n * Browser version of the graphology GEXF parser.\n */\nvar isGraphConstructor = require('graphology-utils/is-graph-constructor'),\n    helpers = require('../common/helpers.js');\n\nvar cast = helpers.cast;\n\n/**\n * Function checking whether the given value is a NaN.\n *\n * @param  {any} value - Value to test.\n * @return {boolean}\n */\nfunction isReallyNaN(value) {\n  return value !== value;\n}\n\n/**\n * Function used to convert a viz:color attribute into a CSS rgba? string.\n *\n * @param  {Node}   element - DOM element.\n * @return {string}\n */\nfunction toRGBString(element) {\n  var a = element.getAttribute('a'),\n      r = element.getAttribute('r'),\n      g = element.getAttribute('g'),\n      b = element.getAttribute('b');\n\n  return a ?\n    ('rgba(' + r + ',' + g + ',' + b + ',' + a + ')') :\n    ('rgb(' + r + ',' + g + ',' + b + ')');\n}\n\n/**\n * Function returning the first matching tag of the `viz` namespace matching\n * the desired tag name.\n *\n * @param  {Node}   element - Target DOM element.\n * @param  {string} name    - Tag name.\n * @return {Node}\n */\nfunction getFirstMatchingVizTag(element, name) {\n  var vizElement = element.getElementsByTagName('viz:' + name)[0];\n\n  if (!vizElement)\n    vizElement = element.getElementsByTagNameNS('viz', name)[0];\n\n  if (!vizElement)\n    vizElement = element.getElementsByTagName(name)[0];\n\n  return vizElement;\n}\n\n/**\n * Function used to collect meta information.\n *\n * @param  {Array<Node>} elements - Target DOM element.\n * @return {object}\n */\nfunction collectMeta(elements) {\n  var meta = {},\n      element;\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n\n    if (element.nodeName === '#text')\n      continue;\n\n    meta[element.tagName.toLowerCase()] = element.textContent;\n  }\n\n  return meta;\n}\n\n/**\n * Function used to extract the model from the right elements.\n *\n * @param  {Array<Node>} elements - Target DOM elements.\n * @return {array}                - The model & default attributes.\n */\nfunction extractModel(elements) {\n  var model = {},\n      defaults = {},\n      element,\n      defaultElement,\n      id;\n\n  for (var i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    id = element.getAttribute('id') || element.getAttribute('for');\n\n    model[id] = {\n      id: id,\n      type: element.getAttribute('type') || 'string',\n      title: !isReallyNaN(+id) ?\n        (element.getAttribute('title') || id) :\n        id\n    };\n\n    // Default?\n    defaultElement = element.getElementsByTagName('default')[0];\n\n    if (defaultElement)\n      defaults[model[id].title] = cast(\n        model[id].type,\n        defaultElement.textContent\n      );\n  }\n\n  return [model, defaults];\n}\n\n/**\n * Function used to collect an element's attributes.\n *\n * @param  {object} model   - Data model to use.\n * @param  {Node}   element - Target DOM element.\n * @return {object}         - The collected attributes.\n */\nfunction collectAttributes(model, element) {\n  var data = {},\n      label = element.getAttribute('label'),\n      weight = element.getAttribute('weight');\n\n  if (label)\n    data.label = label;\n\n  if (weight)\n    data.weight = +weight;\n\n  var valueElements = element.getElementsByTagName('attvalue'),\n      valueElement,\n      id;\n\n  for (var i = 0, l = valueElements.length; i < l; i++) {\n    valueElement = valueElements[i];\n    id = (\n      valueElement.getAttribute('id') ||\n      valueElement.getAttribute('for')\n    );\n\n    data[model[id].title] = cast(\n      model[id].type,\n      valueElement.getAttribute('value')\n    );\n  }\n\n  // TODO: shortcut here to avoid viz when namespace is not set\n\n  // Attempting to find viz namespace tags\n\n  //-- 1) Color\n  var vizElement = getFirstMatchingVizTag(element, 'color');\n\n  if (vizElement)\n    data.color = toRGBString(vizElement);\n\n  //-- 2) Size\n  vizElement = getFirstMatchingVizTag(element, 'size');\n\n  if (vizElement)\n    data.size = +vizElement.getAttribute('value');\n\n  //-- 3) Position\n  var x, y, z;\n\n  vizElement = getFirstMatchingVizTag(element, 'position');\n\n  if (vizElement) {\n    x = vizElement.getAttribute('x');\n    y = vizElement.getAttribute('y');\n    z = vizElement.getAttribute('z');\n\n    if (x)\n      data.x = +x;\n    if (y)\n      data.y = +y;\n    if (z)\n      data.z = +z;\n  }\n\n  //-- 4) Shape\n  vizElement = getFirstMatchingVizTag(element, 'shape');\n\n  if (vizElement)\n    data.shape = vizElement.getAttribute('value');\n\n  //-- 5) Thickness\n  vizElement = getFirstMatchingVizTag(element, 'thickness');\n\n  if (vizElement)\n    data.thickness = +vizElement.getAttribute('value');\n\n  return data;\n}\n\n/**\n * Function taking either a string or a document and returning a\n * graphology instance.\n *\n * @param  {function}        Graph  - A graphology constructor.\n * @param  {string|Document} source - The source to parse.\n */\n\n// TODO: option to map the data to the attributes for customization, nodeModel, edgeModel, nodeReducer, edgeReducer\n// TODO: option to disable the model mapping heuristic\nmodule.exports = function parse(Graph, source) {\n  var xmlDoc = source;\n\n  var element,\n      result,\n      type,\n      attributes,\n      id,\n      s,\n      t,\n      i,\n      l;\n\n  if (!isGraphConstructor(Graph))\n    throw new Error('graphology-gexf/browser/parser: invalid Graph constructor.');\n\n  // If source is a string, we are going to parse it\n  if (typeof source === 'string')\n    xmlDoc = (new DOMParser()).parseFromString(source, 'application/xml');\n\n  if (!(xmlDoc instanceof Document))\n    throw new Error('graphology-gexf/browser/parser: source should either be a XML document or a string.');\n\n  // Finding useful elements\n  var GRAPH_ELEMENT = xmlDoc.getElementsByTagName('graph')[0],\n      META_ELEMENT = xmlDoc.getElementsByTagName('meta')[0],\n      META_ELEMENTS = (META_ELEMENT && META_ELEMENT.childNodes) || [],\n      NODE_ELEMENTS = xmlDoc.getElementsByTagName('node'),\n      EDGE_ELEMENTS = xmlDoc.getElementsByTagName('edge'),\n      MODEL_ELEMENTS = xmlDoc.getElementsByTagName('attributes'),\n      NODE_MODEL_ELEMENTS = [],\n      EDGE_MODEL_ELEMENTS = [];\n\n  for (i = 0, l = MODEL_ELEMENTS.length; i < l; i++) {\n    element = MODEL_ELEMENTS[i];\n\n    if (element.getAttribute('class') === 'node')\n      NODE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');\n    else if (element.getAttribute('class') === 'edge')\n      EDGE_MODEL_ELEMENTS = element.getElementsByTagName('attribute');\n  }\n\n  // Information\n  var DEFAULT_EDGE_TYPE = GRAPH_ELEMENT.getAttribute('defaultedgetype') || 'undirected';\n\n  if (DEFAULT_EDGE_TYPE === 'mutual')\n    DEFAULT_EDGE_TYPE = 'undirected';\n\n  // Computing models\n  result = extractModel(NODE_MODEL_ELEMENTS);\n\n  var NODE_MODEL = result[0],\n      NODE_DEFAULT_ATTRIBUTES = result[1];\n\n  result = extractModel(EDGE_MODEL_ELEMENTS);\n\n  var EDGE_MODEL = result[0],\n      EDGE_DEFAULT_ATTRIBUTES = result[1];\n\n  // Polling the first edge to guess the type of the edges\n  var graphType = EDGE_ELEMENTS[0] ?\n    (EDGE_ELEMENTS[0].getAttribute('type') || DEFAULT_EDGE_TYPE) :\n    'mixed';\n\n  // Instantiating our graph\n  var graph = new Graph({\n    type: graphType,\n    defaultNodeAttributes: NODE_DEFAULT_ATTRIBUTES,\n    defaultEdgeAttributes: EDGE_DEFAULT_ATTRIBUTES\n  });\n\n  // Collecting meta\n  var meta = collectMeta(META_ELEMENTS),\n      lastModifiedDate = META_ELEMENT && META_ELEMENT.getAttribute('lastmodifieddate');\n\n  graph.replaceAttributes(meta);\n\n  if (lastModifiedDate)\n    graph.setAttribute('lastModifiedDate', lastModifiedDate);\n\n  // Adding nodes\n  for (i = 0, l = NODE_ELEMENTS.length; i < l; i++) {\n    element = NODE_ELEMENTS[i];\n\n    graph.addNode(\n      element.getAttribute('id'),\n      collectAttributes(NODE_MODEL, element)\n    );\n  }\n\n  // Adding edges\n  for (i = 0, l = EDGE_ELEMENTS.length; i < l; i++) {\n    element = EDGE_ELEMENTS[i];\n\n    id = element.getAttribute('id');\n    type = element.getAttribute('type') || DEFAULT_EDGE_TYPE;\n    s = element.getAttribute('source');\n    t = element.getAttribute('target');\n    attributes = collectAttributes(EDGE_MODEL, element);\n\n    // If we encountered an edge with a different type, we upgrade the graph\n    if (type !== graph.type && graph.type !== 'mixed') {\n      graph.upgradeToMixed();\n    }\n\n    // If we encountered twice the same edge, we upgrade the graph\n    if (\n      !graph.multi &&\n      (\n        (type === 'directed' && graph.hasDirectedEdge(s, t)) ||\n        (graph.hasUndirectedEdge(s, t))\n      )\n    ) {\n      graph.upgradeToMulti();\n    }\n\n    if (id) {\n      if (type === 'directed')\n        graph.addDirectedEdgeWithKey(id, s, t, attributes);\n      else\n        graph.addUndirectedEdgeWithKey(id, s, t, attributes);\n    }\n    else {\n      if (type === 'directed')\n        graph.addDirectedEdge(s, t, attributes);\n      else\n        graph.addUndirectedEdge(s, t, attributes);\n    }\n  }\n\n  return graph;\n};\n", "/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n", "\nfunction isFalse(s) {\n  return typeof s !== 'number' && !s;\n}\n\nfunction strval(s) {\n  if (typeof s == 'string') {\n    return s;\n  }\n  else if (typeof s == 'number') {\n    return s+'';\n  }\n  else if (typeof s == 'function') {\n    return s();\n  }\n  else if (s instanceof XMLWriter) {\n    return s.toString();\n  }\n  else throw Error('Bad Parameter');\n}\n\nfunction XMLWriter(indent, callback) {\n\n    if (!(this instanceof XMLWriter)) {\n        return new XMLWriter();\n    }\n\n    this.name_regex = /[_:A-Za-z][-._:A-Za-z0-9]*/;\n    this.indent = indent ? true : false;\n    this.indentString = this.indent && typeof indent === 'string' ? indent : '    ';\n    this.output = '';\n    this.stack = [];\n    this.tags = 0;\n    this.attributes = 0;\n    this.attribute = 0;\n    this.texts = 0;\n    this.comment = 0;\n    this.dtd = 0;\n    this.root = '';\n    this.pi = 0;\n    this.cdata = 0;\n    this.started_write = false;\n    this.writer;\n    this.writer_encoding = 'UTF-8';\n\n    if (typeof callback == 'function') {\n        this.writer = callback;\n    } else {\n        this.writer = function (s, e) {\n            this.output += s;\n        }\n    }\n}\n\nXMLWriter.prototype = {\n    toString : function () {\n        this.flush();\n        return this.output;\n    },\n\n    indenter : function () {\n      if (this.indent) {\n        this.write('\\n');\n        for (var i = 1; i < this.tags; i++) {\n          this.write(this.indentString);\n        }\n      }\n    },\n\n    write : function () {\n        for (var i = 0; i < arguments.length; i++) {\n            this.writer(arguments[i], this.writer_encoding);\n        }\n    },\n\n\n    flush : function () {\n        for (var i = this.tags; i > 0; i--) {\n            this.endElement();\n        }\n        this.tags = 0;\n    },\n\n    startDocument : function (version, encoding, standalone) {\n        if (this.tags || this.attributes) return this;\n\n        this.startPI('xml');\n        this.startAttribute('version');\n        this.text(typeof version == \"string\" ? version : \"1.0\");\n        this.endAttribute();\n        if (typeof encoding == \"string\") {\n            this.startAttribute('encoding');\n            this.text(encoding);\n            this.endAttribute();\n            this.writer_encoding = encoding;\n        }\n        if (standalone) {\n            this.startAttribute('standalone');\n            this.text(\"yes\");\n            this.endAttribute();\n        }\n        this.endPI();\n        if (!this.indent) {\n          this.write('\\n');\n        }\n        return this;\n    },\n\n    endDocument : function () {\n        if (this.attributes) this.endAttributes();\n        return this;\n    },\n\n    writeElement : function (name, content) {\n        return this.startElement(name).text(content).endElement();\n    },\n\n    writeElementNS : function (prefix, name, uri, content) {\n        if (!content) {\n            content = uri;\n        }\n        return this.startElementNS(prefix, name, uri).text(content).endElement();\n    },\n\n    startElement : function (name) {\n        name = strval(name);\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (this.tags === 0 && this.root && this.root !== name) throw Error('Invalid Parameter');\n        if (this.attributes) this.endAttributes();\n        ++this.tags;\n        this.texts = 0;\n        if (this.stack.length > 0)\n          this.stack[this.stack.length-1].containsTag = true;\n\n        this.stack.push({\n            name: name,\n            tags: this.tags\n        });\n        if (this.started_write) this.indenter();\n        this.write('<', name);\n        this.startAttributes();\n        this.started_write = true;\n        return this;\n    },\n    startElementNS : function (prefix, name, uri) {\n        prefix = strval(prefix);\n        name = strval(name);\n\n        if (!prefix.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (this.attributes) this.endAttributes();\n        ++this.tags;\n        this.texts = 0;\n        if (this.stack.length > 0)\n          this.stack[this.stack.length-1].containsTag = true;\n\n        this.stack.push({\n            name: prefix + ':' + name,\n            tags: this.tags\n        });\n        if (this.started_write) this.indenter();\n        this.write('<', prefix + ':' + name);\n        this.startAttributes();\n        this.started_write = true;\n        return this;\n    },\n\n    endElement : function () {\n        if (!this.tags) return this;\n        var t = this.stack.pop();\n        if (this.attributes > 0) {\n            if (this.attribute) {\n                if (this.texts) this.endAttribute();\n                this.endAttribute();\n            }\n            this.write('/');\n            this.endAttributes();\n        } else {\n            if (t.containsTag) this.indenter();\n            this.write('</', t.name, '>');\n        }\n        --this.tags;\n        this.texts = 0;\n        return this;\n    },\n\n    writeAttribute : function (name, content) {\n        if (typeof content == 'function') {\n          content = content();\n        }\n        if (isFalse(content)) {\n           return this;\n        }\n        return this.startAttribute(name).text(content).endAttribute();\n    },\n    writeAttributeNS : function (prefix, name, uri, content) {\n        if (!content) {\n            content = uri;\n        }\n        if (typeof content == 'function') {\n          content = content();\n        }\n        if (isFalse(content)) {\n          return this;\n        }\n        return this.startAttributeNS(prefix, name, uri).text(content).endAttribute();\n    },\n\n    startAttributes : function () {\n        this.attributes = 1;\n        return this;\n    },\n\n    endAttributes : function () {\n        if (!this.attributes) return this;\n        if (this.attribute) this.endAttribute();\n        this.attributes = 0;\n        this.attribute = 0;\n        this.texts = 0;\n        this.write('>');\n        return this;\n    },\n\n    startAttribute : function (name) {\n        name = strval(name);\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!this.attributes && !this.pi) return this;\n        if (this.attribute) return this;\n        this.attribute = 1;\n        this.write(' ', name, '=\"');\n        return this;\n    },\n    startAttributeNS : function (prefix, name, uri) {\n        prefix = strval(prefix);\n        name = strval(name);\n\n        if (!prefix.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (!this.attributes && !this.pi) return this;\n        if (this.attribute) return this;\n        this.attribute = 1;\n        this.write(' ', prefix + ':' + name, '=\"');\n        return this;\n    },\n    endAttribute : function () {\n        if (!this.attribute) return this;\n        this.attribute = 0;\n        this.texts = 0;\n        this.write('\"');\n        return this;\n    },\n\n    text : function (content) {\n        content = strval(content);\n        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;\n        if (this.attributes && this.attribute) {\n            ++this.texts;\n            this.write(content\n                       .replace(/&/g, '&amp;')\n                       .replace(/</g, '&lt;')\n                       .replace(/\"/g, '&quot;')\n                       .replace(/\\t/g, '&#x9;')\n                       .replace(/\\n/g, '&#xA;')\n                       .replace(/\\r/g, '&#xD;')\n                      );\n            return this;\n        } else if (this.attributes && !this.attribute) {\n            this.endAttributes();\n        }\n        if (this.comment || this.cdata) {\n            this.write(content);\n        }\n        else {\n          this.write(content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'));\n        }\n        ++this.texts;\n        this.started_write = true;\n        return this;\n    },\n\n    writeComment : function (content) {\n        return this.startComment().text(content).endComment();\n    },\n\n    startComment : function () {\n        if (this.comment) return this;\n        if (this.attributes) this.endAttributes();\n        this.indenter();\n        this.write('<!--');\n        this.comment = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endComment : function () {\n        if (!this.comment) return this;\n        this.write('-->');\n        this.comment = 0;\n        return this;\n    },\n\n    writeDocType : function (name, pubid, sysid, subset) {\n        return this.startDocType(name, pubid, sysid, subset).endDocType()\n    },\n\n    startDocType : function (name, pubid, sysid, subset) {\n        if (this.dtd || this.tags) return this;\n\n        name = strval(name);\n        pubid = pubid ? strval(pubid) : pubid;\n        sysid = sysid ? strval(sysid) : sysid;\n        subset = subset ? strval(subset) : subset;\n\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (pubid && !pubid.match(/^[\\w\\-][\\w\\s\\-\\/\\+\\:\\.]*/)) throw Error('Invalid Parameter');\n        if (sysid && !sysid.match(/^[\\w\\.][\\w\\-\\/\\\\\\:\\.]*/)) throw Error('Invalid Parameter');\n        if (subset && !subset.match(/[\\w\\s\\<\\>\\+\\.\\!\\#\\-\\?\\*\\,\\(\\)\\|]*/)) throw Error('Invalid Parameter');\n\n        pubid = pubid ? ' PUBLIC \"' + pubid + '\"' : (sysid) ? ' SYSTEM' : '';\n        sysid = sysid ? ' \"' + sysid + '\"' : '';\n        subset = subset ? ' [' + subset + ']': '';\n\n        if (this.started_write) this.indenter();\n        this.write('<!DOCTYPE ', name, pubid, sysid, subset);\n        this.root = name;\n        this.dtd = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endDocType : function () {\n        if (!this.dtd) return this;\n        this.write('>');\n        return this;\n    },\n\n    writePI : function (name, content) {\n        return this.startPI(name).text(content).endPI()\n    },\n\n    startPI : function (name) {\n        name = strval(name);\n        if (!name.match(this.name_regex)) throw Error('Invalid Parameter');\n        if (this.pi) return this;\n        if (this.attributes) this.endAttributes();\n        if (this.started_write) this.indenter();\n        this.write('<?', name);\n        this.pi = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endPI : function () {\n        if (!this.pi) return this;\n        this.write('?>');\n        this.pi = 0;\n        return this;\n    },\n\n    writeCData : function (content) {\n        return this.startCData().text(content).endCData();\n    },\n\n    startCData : function () {\n        if (this.cdata) return this;\n        if (this.attributes) this.endAttributes();\n        this.indenter();\n        this.write('<![CDATA[');\n        this.cdata = 1;\n        this.started_write = true;\n        return this;\n    },\n\n    endCData : function () {\n        if (!this.cdata) return this;\n        this.write(']]>');\n        this.cdata = 0;\n        return this;\n    },\n\n    writeRaw : function(content) {\n        content = strval(content);\n        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;\n        if (this.attributes && this.attribute) {\n            ++this.texts;\n            this.write(content.replace('&', '&amp;').replace('\"', '&quot;'));\n            return this;\n        } else if (this.attributes && !this.attribute) {\n            this.endAttributes();\n        }\n        ++this.texts;\n        this.write(content);\n        this.started_write = true;\n        return this;\n    }\n\n}\n\nmodule.exports = XMLWriter;\n", "module.exports = require('./lib/xml-writer.js');\n", "/**\n * Graphology Common GEXF Writer\n * ==============================\n *\n * GEXF writer working for both node.js & the browser.\n */\nvar isGraph = require('graphology-utils/is-graph'),\n    XMLWriter = require('xml-writer');\n\n// TODO: options => prettyPrint, nodeModel, edgeModel\n// TODO: handle object in color, position with object for viz\n\n/**\n * Constants.\n */\nvar GEXF_NAMESPACE = 'http://www.gexf.net/1.2draft',\n    GEXF_VIZ_NAMESPACE = 'http:///www.gexf.net/1.1draft/viz';\n\nvar DEFAULTS = {\n  encoding: 'UTF-8',\n  pretty: true\n};\n\n// var VALID_GEXF_TYPES = new Set([\n//   'integer',\n//   'long',\n//   'double',\n//   'float',\n//   'boolean',\n//   'liststring',\n//   'string',\n//   'anyURI'\n// ]);\n\nvar VIZ_RESERVED_NAMES = new Set([\n  'color',\n  'size',\n  'x',\n  'y',\n  'z',\n  'shape',\n  'thickness'\n]);\n\nvar RGBA_TEST = /^\\s*rgba?\\s*\\(/i,\n    RGBA_MATCH = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*(?:,\\s*([.0-9]*))?\\)\\s*$/;\n\n/**\n * Function used to transform a CSS color into a RGBA object.\n *\n * @param  {string} value - Target value.\n * @return {object}\n */\nfunction CSSColorToRGBA(value) {\n  if (!value || typeof value !== 'string')\n    return {};\n\n  if (value[0] === '#') {\n    value = value.slice(1);\n\n    return (value.length === 3) ?\n      {\n        r: parseInt(value[0] + value[0], 16),\n        g: parseInt(value[1] + value[1], 16),\n        b: parseInt(value[2] + value[2], 16)\n      } :\n      {\n        r: parseInt(value[0] + value[1], 16),\n        g: parseInt(value[2] + value[3], 16),\n        b: parseInt(value[4] + value[5], 16)\n      };\n  }\n  else if (RGBA_TEST.test(value)) {\n    var result = {};\n\n    value = value.match(RGBA_MATCH);\n    result.r = +value[1];\n    result.g = +value[2];\n    result.b = +value[3];\n\n    if (value[4])\n      result.a = +value[4];\n\n    return result;\n  }\n\n  return {};\n}\n\n/**\n * Function used to map an element's attributes to a standardized map of\n * GEXF expected properties (label, viz, attributes).\n *\n * @param  {string} type       - The element's type\n * @param  {object} attributes - The element's attributes.\n * @return {object}\n */\nfunction DEFAULT_ELEMENT_REDUCER(type, attributes) {\n  var output = {},\n      name;\n\n  for (name in attributes) {\n    if (name === 'label') {\n      output.label = attributes.label;\n    }\n    else if (type === 'edge' && name === 'weight') {\n      output.weight = attributes.weight;\n    }\n    else if (VIZ_RESERVED_NAMES.has(name)) {\n      output.viz = output.viz || {};\n      output.viz[name] = attributes[name];\n    }\n    else {\n      output.attributes = output.attributes || {};\n      output.attributes[name] = attributes[name];\n    }\n  }\n\n  return output;\n}\n\nvar DEFAULT_NODE_REDUCER = DEFAULT_ELEMENT_REDUCER.bind(null, 'node'),\n    DEFAULT_EDGE_REDUCER = DEFAULT_ELEMENT_REDUCER.bind(null, 'edge');\n\n/**\n * Function used to check whether the given integer is 32 bits or not.\n *\n * @param  {number} number - Target number.\n * @return {boolean}\n */\nfunction is32BitInteger(number) {\n  return number <= 0x7FFFFFFF && number >= -0x7FFFFFFF;\n}\n\n/**\n * Function used to detect a JavaScript's value type in the GEXF model.\n *\n * @param  {any}    value - Target value.\n * @return {string}\n */\nfunction detectValueType(value) {\n  if (Array.isArray(value))\n    return 'liststring';\n  if (typeof value === 'boolean')\n    return 'boolean';\n  if (typeof value === 'object')\n    return 'string';\n\n  // Numbers\n  if (typeof value === 'number') {\n\n    // Integer\n    if (value === (value | 0)) {\n\n      // Long (JavaScript integer can go up to 53 bit)?\n      return is32BitInteger(value) ? 'integer' : 'long';\n    }\n\n    // JavaScript numbers are 64 bit float, hence the double\n    return 'double';\n  }\n\n  return 'string';\n}\n\n/**\n * Function used to cast the given value into the given type.\n *\n * @param  {string} type  - Target type.\n * @param  {any}    value - Value to cast.\n * @return {string}\n */\nfunction cast(type, value) {\n  if (type === 'liststring' && Array.isArray(value))\n    return value.join('|');\n  return '' + value;\n}\n\n/**\n * Function used to collect data from a graph's nodes.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} reducer - Function reducing the nodes attributes.\n * @return {array}\n */\nfunction collectNodeData(graph, reducer) {\n  var nodes = graph.nodes(),\n      data;\n\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    data = reducer(graph.getNodeAttributes(nodes[i]));\n    data.key = nodes[i];\n    nodes[i] = data;\n  }\n\n  return nodes;\n}\n\n/**\n * Function used to collect data from a graph's edges.\n *\n * @param  {Graph}    graph   - Target graph.\n * @param  {function} reducer - Function reducing the edges attributes.\n * @return {array}\n */\nfunction collectEdgeData(graph, reducer) {\n  var edges = graph.edges(),\n      data;\n\n  for (var i = 0, l = edges.length; i < l; i++) {\n    data = reducer(graph.getEdgeAttributes(edges[i]));\n    data.key = edges[i];\n    data.source = graph.source(edges[i]);\n    data.target = graph.target(edges[i]);\n    data.undirected = graph.undirected(edges[i]);\n    edges[i] = data;\n  }\n\n  return edges;\n}\n\n/**\n * Function used to infer the model of the graph's nodes or edges.\n *\n * @param  {array} elements - The graph's relevant elements.\n * @return {array}\n */\nfunction inferModel(elements) {\n  var model = {},\n      attributes,\n      type,\n      k;\n\n  // Testing every attributes\n  for (var i = 0, l = elements.length; i < l; i++) {\n    attributes = elements[i].attributes;\n\n    if (!attributes)\n      continue;\n\n    for (k in attributes) {\n      type = detectValueType(attributes[k]);\n\n      if (!model[k])\n        model[k] = type;\n      else {\n        if (model[k] === 'integer' && type === 'long')\n          model[k] = type;\n        else if (model[k] !== type)\n          model[k] = 'string';\n      }\n    }\n  }\n\n  // TODO: check default values\n  return model;\n}\n\n/**\n * Function used to write a model.\n *\n * @param {XMLWriter} writer     - The writer to use.\n * @param {object}    model      - Model to write.\n * @param {string}    modelClass - Class of the model.\n */\nfunction writeModel(writer, model, modelClass) {\n  var name;\n\n  if (!Object.keys(model).length)\n    return;\n\n  writer.startElement('attributes');\n  writer.writeAttribute('class', modelClass);\n\n  for (name in model) {\n    writer.startElement('attribute');\n    writer.writeAttribute('id', name);\n    writer.writeAttribute('title', name);\n    writer.writeAttribute('type', model[name]);\n    writer.endElement();\n  }\n\n  writer.endElement();\n}\n\nfunction writeElements(writer, type, model, elements) {\n  var emptyModel = !Object.keys(model).length,\n      element,\n      name,\n      color,\n      edgeType,\n      attributes,\n      viz,\n      k,\n      i,\n      l;\n\n  writer.startElement(type + 's');\n\n  for (i = 0, l = elements.length; i < l; i++) {\n    element = elements[i];\n    attributes = element.attributes;\n    viz = element.viz;\n\n    writer.startElement(type);\n    writer.writeAttribute('id', element.key);\n\n    if (type === 'edge') {\n      edgeType = element.undirected ? 'undirected' : 'directed';\n\n      if (edgeType !== writer.defaultEdgeType)\n        writer.writeAttribute('type', edgeType);\n\n      writer.writeAttribute('source', element.source);\n      writer.writeAttribute('target', element.target);\n\n      if ('weight' in element)\n        writer.writeAttribute('weight', element.weight);\n    }\n\n    if (element.label)\n      writer.writeAttribute('label', element.label);\n\n    if (!emptyModel && attributes) {\n      writer.startElement('attvalues');\n\n      for (name in model) {\n        if (name in attributes) {\n          writer.startElement('attvalue');\n          writer.writeAttribute('for', name);\n          writer.writeAttribute('value', cast(model[name], attributes[name]));\n          writer.endElement();\n        }\n      }\n\n      writer.endElement();\n    }\n\n    if (viz) {\n\n      //-- 1) Color\n      if (viz.color) {\n        color = CSSColorToRGBA(viz.color);\n\n        writer.startElementNS('viz', 'color');\n\n        for (k in color)\n          writer.writeAttribute(k, color[k]);\n\n        writer.endElement();\n      }\n\n      //-- 2) Size\n      if ('size' in viz) {\n        writer.startElementNS('viz', 'size');\n        writer.writeAttribute('value', viz.size);\n        writer.endElement();\n      }\n\n      //-- 3) Position\n      if ('x' in viz || 'y' in viz || 'z' in viz) {\n        writer.startElementNS('viz', 'position');\n\n        if ('x' in viz)\n          writer.writeAttribute('x', viz.x);\n\n        if ('y' in viz)\n          writer.writeAttribute('y', viz.y);\n\n        if ('z' in viz)\n          writer.writeAttribute('z', viz.z);\n\n        writer.endElement();\n      }\n\n      //-- 4) Shape\n      if (viz.shape) {\n        writer.startElementNS('viz', 'shape');\n        writer.writeAttribute('value', viz.shape);\n        writer.endElement();\n      }\n\n      //-- 5) Thickness\n      if ('thickness' in viz) {\n        writer.startElementNS('viz', 'thickness');\n        writer.writeAttribute('value', viz.thickness);\n        writer.endElement();\n      }\n    }\n\n    writer.endElement();\n  }\n\n  writer.endElement();\n}\n\n/**\n * Function taking a graphology instance & outputting a gexf string.\n *\n * @param  {Graph}  graph        - Target graphology instance.\n * @param  {object} options      - Options:\n * @param  {string}   [encoding]   - Character encoding.\n * @paral  {boolean}  [pretty]     - Whether to pretty print output.\n * @return {string}              - GEXF string.\n */\nmodule.exports = function write(graph, options) {\n  if (!isGraph(graph))\n    throw new Error('graphology-gexf/writer: invalid graphology instance.');\n\n  options = options || {};\n\n  var indent = options.pretty === false ? false : '  ';\n\n  var writer = new XMLWriter(indent);\n\n  writer.startDocument('1.0', options.encoding || DEFAULTS.encoding);\n\n  // Starting gexf\n  writer.startElement('gexf');\n  writer.writeAttribute('version', '1.2');\n  writer.writeAttribute('xmlns', GEXF_NAMESPACE);\n  writer.writeAttribute('xmlns:viz', GEXF_VIZ_NAMESPACE);\n\n  // Processing meta\n  writer.startElement('meta');\n  var graphAttributes = graph.getAttributes();\n\n  if (graphAttributes.lastModifiedDate)\n    writer.writeAttribute('lastmodifieddate', graphAttributes.lastModifiedDate);\n\n  for (var k in graphAttributes) {\n    if (k !== 'lastModifiedDate')\n      writer.writeElement(k, graphAttributes[k]);\n  }\n\n  writer.endElement();\n  writer.startElement('graph');\n  writer.defaultEdgeType = graph.type === 'mixed' ?\n    'directed' :\n    graph.type;\n\n  writer.writeAttribute(\n    'defaultedgetype',\n    writer.defaultEdgeType\n  );\n\n  // Processing model\n  var nodes = collectNodeData(graph, DEFAULT_NODE_REDUCER),\n      edges = collectEdgeData(graph, DEFAULT_EDGE_REDUCER);\n\n  var nodeModel = inferModel(nodes);\n\n  writeModel(writer, nodeModel, 'node');\n\n  var edgeModel = inferModel(edges);\n\n  writeModel(writer, edgeModel, 'edge');\n\n  // Processing nodes\n  writeElements(writer, 'node', nodeModel, nodes);\n\n  // Processing edges\n  writeElements(writer, 'edge', edgeModel, edges);\n\n  return writer.toString();\n};\n", "/**\n * Graphology Browser GEXF Endpoint\n * =================================\n *\n * Endpoint gathering both parser & writer for the browser.\n */\nexports.parse = require('./parser.js');\nexports.write = require('../common/writer.js');\n"],
  "mappings": "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",
  "names": ["require_xml_writer"]
}
