import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/graphology-utils/is-graph-constructor.js
var require_is_graph_constructor = __commonJS({
  "node_modules/graphology-utils/is-graph-constructor.js"(exports, module) {
    module.exports = function isGraphConstructor(value) {
      return value !== null && typeof value === "function" && typeof value.prototype === "object" && typeof value.prototype.addUndirectedEdgeWithKey === "function" && typeof value.prototype.dropNode === "function";
    };
  }
});

// node_modules/graphology-gexf/common/helpers.js
var require_helpers = __commonJS({
  "node_modules/graphology-gexf/common/helpers.js"(exports) {
    exports.cast = function(type, value) {
      switch (type) {
        case "boolean":
          value = value === "true";
          break;
        case "integer":
        case "long":
        case "float":
        case "double":
          value = +value;
          break;
        case "liststring":
          value = value ? value.split("|") : [];
          break;
        default:
      }
      return value;
    };
  }
});

// node_modules/graphology-gexf/browser/parser.js
var require_parser = __commonJS({
  "node_modules/graphology-gexf/browser/parser.js"(exports, module) {
    var isGraphConstructor = require_is_graph_constructor();
    var helpers = require_helpers();
    var cast = helpers.cast;
    function isReallyNaN(value) {
      return value !== value;
    }
    function toRGBString(element) {
      var a = element.getAttribute("a"), r = element.getAttribute("r"), g = element.getAttribute("g"), b = element.getAttribute("b");
      return a ? "rgba(" + r + "," + g + "," + b + "," + a + ")" : "rgb(" + r + "," + g + "," + b + ")";
    }
    function getFirstMatchingVizTag(element, name) {
      var vizElement = element.getElementsByTagName("viz:" + name)[0];
      if (!vizElement)
        vizElement = element.getElementsByTagNameNS("viz", name)[0];
      if (!vizElement)
        vizElement = element.getElementsByTagName(name)[0];
      return vizElement;
    }
    function collectMeta(elements) {
      var meta = {}, element;
      for (var i = 0, l = elements.length; i < l; i++) {
        element = elements[i];
        if (element.nodeName === "#text")
          continue;
        meta[element.tagName.toLowerCase()] = element.textContent;
      }
      return meta;
    }
    function extractModel(elements) {
      var model = {}, defaults = {}, element, defaultElement, id;
      for (var i = 0, l = elements.length; i < l; i++) {
        element = elements[i];
        id = element.getAttribute("id") || element.getAttribute("for");
        model[id] = {
          id,
          type: element.getAttribute("type") || "string",
          title: !isReallyNaN(+id) ? element.getAttribute("title") || id : id
        };
        defaultElement = element.getElementsByTagName("default")[0];
        if (defaultElement)
          defaults[model[id].title] = cast(
            model[id].type,
            defaultElement.textContent
          );
      }
      return [model, defaults];
    }
    function collectAttributes(model, element) {
      var data = {}, label = element.getAttribute("label"), weight = element.getAttribute("weight");
      if (label)
        data.label = label;
      if (weight)
        data.weight = +weight;
      var valueElements = element.getElementsByTagName("attvalue"), valueElement, id;
      for (var i = 0, l = valueElements.length; i < l; i++) {
        valueElement = valueElements[i];
        id = valueElement.getAttribute("id") || valueElement.getAttribute("for");
        data[model[id].title] = cast(
          model[id].type,
          valueElement.getAttribute("value")
        );
      }
      var vizElement = getFirstMatchingVizTag(element, "color");
      if (vizElement)
        data.color = toRGBString(vizElement);
      vizElement = getFirstMatchingVizTag(element, "size");
      if (vizElement)
        data.size = +vizElement.getAttribute("value");
      var x, y, z;
      vizElement = getFirstMatchingVizTag(element, "position");
      if (vizElement) {
        x = vizElement.getAttribute("x");
        y = vizElement.getAttribute("y");
        z = vizElement.getAttribute("z");
        if (x)
          data.x = +x;
        if (y)
          data.y = +y;
        if (z)
          data.z = +z;
      }
      vizElement = getFirstMatchingVizTag(element, "shape");
      if (vizElement)
        data.shape = vizElement.getAttribute("value");
      vizElement = getFirstMatchingVizTag(element, "thickness");
      if (vizElement)
        data.thickness = +vizElement.getAttribute("value");
      return data;
    }
    module.exports = function parse(Graph, source) {
      var xmlDoc = source;
      var element, result, type, attributes, id, s, t, i, l;
      if (!isGraphConstructor(Graph))
        throw new Error("graphology-gexf/browser/parser: invalid Graph constructor.");
      if (typeof source === "string")
        xmlDoc = new DOMParser().parseFromString(source, "application/xml");
      if (!(xmlDoc instanceof Document))
        throw new Error("graphology-gexf/browser/parser: source should either be a XML document or a string.");
      var GRAPH_ELEMENT = xmlDoc.getElementsByTagName("graph")[0], META_ELEMENT = xmlDoc.getElementsByTagName("meta")[0], META_ELEMENTS = META_ELEMENT && META_ELEMENT.childNodes || [], NODE_ELEMENTS = xmlDoc.getElementsByTagName("node"), EDGE_ELEMENTS = xmlDoc.getElementsByTagName("edge"), MODEL_ELEMENTS = xmlDoc.getElementsByTagName("attributes"), NODE_MODEL_ELEMENTS = [], EDGE_MODEL_ELEMENTS = [];
      for (i = 0, l = MODEL_ELEMENTS.length; i < l; i++) {
        element = MODEL_ELEMENTS[i];
        if (element.getAttribute("class") === "node")
          NODE_MODEL_ELEMENTS = element.getElementsByTagName("attribute");
        else if (element.getAttribute("class") === "edge")
          EDGE_MODEL_ELEMENTS = element.getElementsByTagName("attribute");
      }
      var DEFAULT_EDGE_TYPE = GRAPH_ELEMENT.getAttribute("defaultedgetype") || "undirected";
      if (DEFAULT_EDGE_TYPE === "mutual")
        DEFAULT_EDGE_TYPE = "undirected";
      result = extractModel(NODE_MODEL_ELEMENTS);
      var NODE_MODEL = result[0], NODE_DEFAULT_ATTRIBUTES = result[1];
      result = extractModel(EDGE_MODEL_ELEMENTS);
      var EDGE_MODEL = result[0], EDGE_DEFAULT_ATTRIBUTES = result[1];
      var graphType = EDGE_ELEMENTS[0] ? EDGE_ELEMENTS[0].getAttribute("type") || DEFAULT_EDGE_TYPE : "mixed";
      var graph = new Graph({
        type: graphType,
        defaultNodeAttributes: NODE_DEFAULT_ATTRIBUTES,
        defaultEdgeAttributes: EDGE_DEFAULT_ATTRIBUTES
      });
      var meta = collectMeta(META_ELEMENTS), lastModifiedDate = META_ELEMENT && META_ELEMENT.getAttribute("lastmodifieddate");
      graph.replaceAttributes(meta);
      if (lastModifiedDate)
        graph.setAttribute("lastModifiedDate", lastModifiedDate);
      for (i = 0, l = NODE_ELEMENTS.length; i < l; i++) {
        element = NODE_ELEMENTS[i];
        graph.addNode(
          element.getAttribute("id"),
          collectAttributes(NODE_MODEL, element)
        );
      }
      for (i = 0, l = EDGE_ELEMENTS.length; i < l; i++) {
        element = EDGE_ELEMENTS[i];
        id = element.getAttribute("id");
        type = element.getAttribute("type") || DEFAULT_EDGE_TYPE;
        s = element.getAttribute("source");
        t = element.getAttribute("target");
        attributes = collectAttributes(EDGE_MODEL, element);
        if (type !== graph.type && graph.type !== "mixed") {
          graph.upgradeToMixed();
        }
        if (!graph.multi && (type === "directed" && graph.hasDirectedEdge(s, t) || graph.hasUndirectedEdge(s, t))) {
          graph.upgradeToMulti();
        }
        if (id) {
          if (type === "directed")
            graph.addDirectedEdgeWithKey(id, s, t, attributes);
          else
            graph.addUndirectedEdgeWithKey(id, s, t, attributes);
        } else {
          if (type === "directed")
            graph.addDirectedEdge(s, t, attributes);
          else
            graph.addUndirectedEdge(s, t, attributes);
        }
      }
      return graph;
    };
  }
});

// node_modules/graphology-utils/is-graph.js
var require_is_graph = __commonJS({
  "node_modules/graphology-utils/is-graph.js"(exports, module) {
    module.exports = function isGraph(value) {
      return value !== null && typeof value === "object" && typeof value.addUndirectedEdgeWithKey === "function" && typeof value.dropNode === "function" && typeof value.multi === "boolean";
    };
  }
});

// node_modules/xml-writer/lib/xml-writer.js
var require_xml_writer = __commonJS({
  "node_modules/xml-writer/lib/xml-writer.js"(exports, module) {
    function isFalse(s) {
      return typeof s !== "number" && !s;
    }
    function strval(s) {
      if (typeof s == "string") {
        return s;
      } else if (typeof s == "number") {
        return s + "";
      } else if (typeof s == "function") {
        return s();
      } else if (s instanceof XMLWriter) {
        return s.toString();
      } else throw Error("Bad Parameter");
    }
    function XMLWriter(indent, callback) {
      if (!(this instanceof XMLWriter)) {
        return new XMLWriter();
      }
      this.name_regex = /[_:A-Za-z][-._:A-Za-z0-9]*/;
      this.indent = indent ? true : false;
      this.indentString = this.indent && typeof indent === "string" ? indent : "    ";
      this.output = "";
      this.stack = [];
      this.tags = 0;
      this.attributes = 0;
      this.attribute = 0;
      this.texts = 0;
      this.comment = 0;
      this.dtd = 0;
      this.root = "";
      this.pi = 0;
      this.cdata = 0;
      this.started_write = false;
      this.writer;
      this.writer_encoding = "UTF-8";
      if (typeof callback == "function") {
        this.writer = callback;
      } else {
        this.writer = function(s, e) {
          this.output += s;
        };
      }
    }
    XMLWriter.prototype = {
      toString: function() {
        this.flush();
        return this.output;
      },
      indenter: function() {
        if (this.indent) {
          this.write("\n");
          for (var i = 1; i < this.tags; i++) {
            this.write(this.indentString);
          }
        }
      },
      write: function() {
        for (var i = 0; i < arguments.length; i++) {
          this.writer(arguments[i], this.writer_encoding);
        }
      },
      flush: function() {
        for (var i = this.tags; i > 0; i--) {
          this.endElement();
        }
        this.tags = 0;
      },
      startDocument: function(version, encoding, standalone) {
        if (this.tags || this.attributes) return this;
        this.startPI("xml");
        this.startAttribute("version");
        this.text(typeof version == "string" ? version : "1.0");
        this.endAttribute();
        if (typeof encoding == "string") {
          this.startAttribute("encoding");
          this.text(encoding);
          this.endAttribute();
          this.writer_encoding = encoding;
        }
        if (standalone) {
          this.startAttribute("standalone");
          this.text("yes");
          this.endAttribute();
        }
        this.endPI();
        if (!this.indent) {
          this.write("\n");
        }
        return this;
      },
      endDocument: function() {
        if (this.attributes) this.endAttributes();
        return this;
      },
      writeElement: function(name, content) {
        return this.startElement(name).text(content).endElement();
      },
      writeElementNS: function(prefix, name, uri, content) {
        if (!content) {
          content = uri;
        }
        return this.startElementNS(prefix, name, uri).text(content).endElement();
      },
      startElement: function(name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (this.tags === 0 && this.root && this.root !== name) throw Error("Invalid Parameter");
        if (this.attributes) this.endAttributes();
        ++this.tags;
        this.texts = 0;
        if (this.stack.length > 0)
          this.stack[this.stack.length - 1].containsTag = true;
        this.stack.push({
          name,
          tags: this.tags
        });
        if (this.started_write) this.indenter();
        this.write("<", name);
        this.startAttributes();
        this.started_write = true;
        return this;
      },
      startElementNS: function(prefix, name, uri) {
        prefix = strval(prefix);
        name = strval(name);
        if (!prefix.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (this.attributes) this.endAttributes();
        ++this.tags;
        this.texts = 0;
        if (this.stack.length > 0)
          this.stack[this.stack.length - 1].containsTag = true;
        this.stack.push({
          name: prefix + ":" + name,
          tags: this.tags
        });
        if (this.started_write) this.indenter();
        this.write("<", prefix + ":" + name);
        this.startAttributes();
        this.started_write = true;
        return this;
      },
      endElement: function() {
        if (!this.tags) return this;
        var t = this.stack.pop();
        if (this.attributes > 0) {
          if (this.attribute) {
            if (this.texts) this.endAttribute();
            this.endAttribute();
          }
          this.write("/");
          this.endAttributes();
        } else {
          if (t.containsTag) this.indenter();
          this.write("</", t.name, ">");
        }
        --this.tags;
        this.texts = 0;
        return this;
      },
      writeAttribute: function(name, content) {
        if (typeof content == "function") {
          content = content();
        }
        if (isFalse(content)) {
          return this;
        }
        return this.startAttribute(name).text(content).endAttribute();
      },
      writeAttributeNS: function(prefix, name, uri, content) {
        if (!content) {
          content = uri;
        }
        if (typeof content == "function") {
          content = content();
        }
        if (isFalse(content)) {
          return this;
        }
        return this.startAttributeNS(prefix, name, uri).text(content).endAttribute();
      },
      startAttributes: function() {
        this.attributes = 1;
        return this;
      },
      endAttributes: function() {
        if (!this.attributes) return this;
        if (this.attribute) this.endAttribute();
        this.attributes = 0;
        this.attribute = 0;
        this.texts = 0;
        this.write(">");
        return this;
      },
      startAttribute: function(name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!this.attributes && !this.pi) return this;
        if (this.attribute) return this;
        this.attribute = 1;
        this.write(" ", name, '="');
        return this;
      },
      startAttributeNS: function(prefix, name, uri) {
        prefix = strval(prefix);
        name = strval(name);
        if (!prefix.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (!this.attributes && !this.pi) return this;
        if (this.attribute) return this;
        this.attribute = 1;
        this.write(" ", prefix + ":" + name, '="');
        return this;
      },
      endAttribute: function() {
        if (!this.attribute) return this;
        this.attribute = 0;
        this.texts = 0;
        this.write('"');
        return this;
      },
      text: function(content) {
        content = strval(content);
        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;
        if (this.attributes && this.attribute) {
          ++this.texts;
          this.write(
            content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;")
          );
          return this;
        } else if (this.attributes && !this.attribute) {
          this.endAttributes();
        }
        if (this.comment || this.cdata) {
          this.write(content);
        } else {
          this.write(content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
        }
        ++this.texts;
        this.started_write = true;
        return this;
      },
      writeComment: function(content) {
        return this.startComment().text(content).endComment();
      },
      startComment: function() {
        if (this.comment) return this;
        if (this.attributes) this.endAttributes();
        this.indenter();
        this.write("<!--");
        this.comment = 1;
        this.started_write = true;
        return this;
      },
      endComment: function() {
        if (!this.comment) return this;
        this.write("-->");
        this.comment = 0;
        return this;
      },
      writeDocType: function(name, pubid, sysid, subset) {
        return this.startDocType(name, pubid, sysid, subset).endDocType();
      },
      startDocType: function(name, pubid, sysid, subset) {
        if (this.dtd || this.tags) return this;
        name = strval(name);
        pubid = pubid ? strval(pubid) : pubid;
        sysid = sysid ? strval(sysid) : sysid;
        subset = subset ? strval(subset) : subset;
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (pubid && !pubid.match(/^[\w\-][\w\s\-\/\+\:\.]*/)) throw Error("Invalid Parameter");
        if (sysid && !sysid.match(/^[\w\.][\w\-\/\\\:\.]*/)) throw Error("Invalid Parameter");
        if (subset && !subset.match(/[\w\s\<\>\+\.\!\#\-\?\*\,\(\)\|]*/)) throw Error("Invalid Parameter");
        pubid = pubid ? ' PUBLIC "' + pubid + '"' : sysid ? " SYSTEM" : "";
        sysid = sysid ? ' "' + sysid + '"' : "";
        subset = subset ? " [" + subset + "]" : "";
        if (this.started_write) this.indenter();
        this.write("<!DOCTYPE ", name, pubid, sysid, subset);
        this.root = name;
        this.dtd = 1;
        this.started_write = true;
        return this;
      },
      endDocType: function() {
        if (!this.dtd) return this;
        this.write(">");
        return this;
      },
      writePI: function(name, content) {
        return this.startPI(name).text(content).endPI();
      },
      startPI: function(name) {
        name = strval(name);
        if (!name.match(this.name_regex)) throw Error("Invalid Parameter");
        if (this.pi) return this;
        if (this.attributes) this.endAttributes();
        if (this.started_write) this.indenter();
        this.write("<?", name);
        this.pi = 1;
        this.started_write = true;
        return this;
      },
      endPI: function() {
        if (!this.pi) return this;
        this.write("?>");
        this.pi = 0;
        return this;
      },
      writeCData: function(content) {
        return this.startCData().text(content).endCData();
      },
      startCData: function() {
        if (this.cdata) return this;
        if (this.attributes) this.endAttributes();
        this.indenter();
        this.write("<![CDATA[");
        this.cdata = 1;
        this.started_write = true;
        return this;
      },
      endCData: function() {
        if (!this.cdata) return this;
        this.write("]]>");
        this.cdata = 0;
        return this;
      },
      writeRaw: function(content) {
        content = strval(content);
        if (!this.tags && !this.comment && !this.pi && !this.cdata) return this;
        if (this.attributes && this.attribute) {
          ++this.texts;
          this.write(content.replace("&", "&amp;").replace('"', "&quot;"));
          return this;
        } else if (this.attributes && !this.attribute) {
          this.endAttributes();
        }
        ++this.texts;
        this.write(content);
        this.started_write = true;
        return this;
      }
    };
    module.exports = XMLWriter;
  }
});

// node_modules/xml-writer/index.js
var require_xml_writer2 = __commonJS({
  "node_modules/xml-writer/index.js"(exports, module) {
    module.exports = require_xml_writer();
  }
});

// node_modules/graphology-gexf/common/writer.js
var require_writer = __commonJS({
  "node_modules/graphology-gexf/common/writer.js"(exports, module) {
    var isGraph = require_is_graph();
    var XMLWriter = require_xml_writer2();
    var GEXF_NAMESPACE = "http://www.gexf.net/1.2draft";
    var GEXF_VIZ_NAMESPACE = "http:///www.gexf.net/1.1draft/viz";
    var DEFAULTS = {
      encoding: "UTF-8",
      pretty: true
    };
    var VIZ_RESERVED_NAMES = /* @__PURE__ */ new Set([
      "color",
      "size",
      "x",
      "y",
      "z",
      "shape",
      "thickness"
    ]);
    var RGBA_TEST = /^\s*rgba?\s*\(/i;
    var RGBA_MATCH = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)\s*(?:,\s*([.0-9]*))?\)\s*$/;
    function CSSColorToRGBA(value) {
      if (!value || typeof value !== "string")
        return {};
      if (value[0] === "#") {
        value = value.slice(1);
        return value.length === 3 ? {
          r: parseInt(value[0] + value[0], 16),
          g: parseInt(value[1] + value[1], 16),
          b: parseInt(value[2] + value[2], 16)
        } : {
          r: parseInt(value[0] + value[1], 16),
          g: parseInt(value[2] + value[3], 16),
          b: parseInt(value[4] + value[5], 16)
        };
      } else if (RGBA_TEST.test(value)) {
        var result = {};
        value = value.match(RGBA_MATCH);
        result.r = +value[1];
        result.g = +value[2];
        result.b = +value[3];
        if (value[4])
          result.a = +value[4];
        return result;
      }
      return {};
    }
    function DEFAULT_ELEMENT_REDUCER(type, attributes) {
      var output = {}, name;
      for (name in attributes) {
        if (name === "label") {
          output.label = attributes.label;
        } else if (type === "edge" && name === "weight") {
          output.weight = attributes.weight;
        } else if (VIZ_RESERVED_NAMES.has(name)) {
          output.viz = output.viz || {};
          output.viz[name] = attributes[name];
        } else {
          output.attributes = output.attributes || {};
          output.attributes[name] = attributes[name];
        }
      }
      return output;
    }
    var DEFAULT_NODE_REDUCER = DEFAULT_ELEMENT_REDUCER.bind(null, "node");
    var DEFAULT_EDGE_REDUCER = DEFAULT_ELEMENT_REDUCER.bind(null, "edge");
    function is32BitInteger(number) {
      return number <= 2147483647 && number >= -2147483647;
    }
    function detectValueType(value) {
      if (Array.isArray(value))
        return "liststring";
      if (typeof value === "boolean")
        return "boolean";
      if (typeof value === "object")
        return "string";
      if (typeof value === "number") {
        if (value === (value | 0)) {
          return is32BitInteger(value) ? "integer" : "long";
        }
        return "double";
      }
      return "string";
    }
    function cast(type, value) {
      if (type === "liststring" && Array.isArray(value))
        return value.join("|");
      return "" + value;
    }
    function collectNodeData(graph, reducer) {
      var nodes = graph.nodes(), data;
      for (var i = 0, l = nodes.length; i < l; i++) {
        data = reducer(graph.getNodeAttributes(nodes[i]));
        data.key = nodes[i];
        nodes[i] = data;
      }
      return nodes;
    }
    function collectEdgeData(graph, reducer) {
      var edges = graph.edges(), data;
      for (var i = 0, l = edges.length; i < l; i++) {
        data = reducer(graph.getEdgeAttributes(edges[i]));
        data.key = edges[i];
        data.source = graph.source(edges[i]);
        data.target = graph.target(edges[i]);
        data.undirected = graph.undirected(edges[i]);
        edges[i] = data;
      }
      return edges;
    }
    function inferModel(elements) {
      var model = {}, attributes, type, k;
      for (var i = 0, l = elements.length; i < l; i++) {
        attributes = elements[i].attributes;
        if (!attributes)
          continue;
        for (k in attributes) {
          type = detectValueType(attributes[k]);
          if (!model[k])
            model[k] = type;
          else {
            if (model[k] === "integer" && type === "long")
              model[k] = type;
            else if (model[k] !== type)
              model[k] = "string";
          }
        }
      }
      return model;
    }
    function writeModel(writer, model, modelClass) {
      var name;
      if (!Object.keys(model).length)
        return;
      writer.startElement("attributes");
      writer.writeAttribute("class", modelClass);
      for (name in model) {
        writer.startElement("attribute");
        writer.writeAttribute("id", name);
        writer.writeAttribute("title", name);
        writer.writeAttribute("type", model[name]);
        writer.endElement();
      }
      writer.endElement();
    }
    function writeElements(writer, type, model, elements) {
      var emptyModel = !Object.keys(model).length, element, name, color, edgeType, attributes, viz, k, i, l;
      writer.startElement(type + "s");
      for (i = 0, l = elements.length; i < l; i++) {
        element = elements[i];
        attributes = element.attributes;
        viz = element.viz;
        writer.startElement(type);
        writer.writeAttribute("id", element.key);
        if (type === "edge") {
          edgeType = element.undirected ? "undirected" : "directed";
          if (edgeType !== writer.defaultEdgeType)
            writer.writeAttribute("type", edgeType);
          writer.writeAttribute("source", element.source);
          writer.writeAttribute("target", element.target);
          if ("weight" in element)
            writer.writeAttribute("weight", element.weight);
        }
        if (element.label)
          writer.writeAttribute("label", element.label);
        if (!emptyModel && attributes) {
          writer.startElement("attvalues");
          for (name in model) {
            if (name in attributes) {
              writer.startElement("attvalue");
              writer.writeAttribute("for", name);
              writer.writeAttribute("value", cast(model[name], attributes[name]));
              writer.endElement();
            }
          }
          writer.endElement();
        }
        if (viz) {
          if (viz.color) {
            color = CSSColorToRGBA(viz.color);
            writer.startElementNS("viz", "color");
            for (k in color)
              writer.writeAttribute(k, color[k]);
            writer.endElement();
          }
          if ("size" in viz) {
            writer.startElementNS("viz", "size");
            writer.writeAttribute("value", viz.size);
            writer.endElement();
          }
          if ("x" in viz || "y" in viz || "z" in viz) {
            writer.startElementNS("viz", "position");
            if ("x" in viz)
              writer.writeAttribute("x", viz.x);
            if ("y" in viz)
              writer.writeAttribute("y", viz.y);
            if ("z" in viz)
              writer.writeAttribute("z", viz.z);
            writer.endElement();
          }
          if (viz.shape) {
            writer.startElementNS("viz", "shape");
            writer.writeAttribute("value", viz.shape);
            writer.endElement();
          }
          if ("thickness" in viz) {
            writer.startElementNS("viz", "thickness");
            writer.writeAttribute("value", viz.thickness);
            writer.endElement();
          }
        }
        writer.endElement();
      }
      writer.endElement();
    }
    module.exports = function write(graph, options) {
      if (!isGraph(graph))
        throw new Error("graphology-gexf/writer: invalid graphology instance.");
      options = options || {};
      var indent = options.pretty === false ? false : "  ";
      var writer = new XMLWriter(indent);
      writer.startDocument("1.0", options.encoding || DEFAULTS.encoding);
      writer.startElement("gexf");
      writer.writeAttribute("version", "1.2");
      writer.writeAttribute("xmlns", GEXF_NAMESPACE);
      writer.writeAttribute("xmlns:viz", GEXF_VIZ_NAMESPACE);
      writer.startElement("meta");
      var graphAttributes = graph.getAttributes();
      if (graphAttributes.lastModifiedDate)
        writer.writeAttribute("lastmodifieddate", graphAttributes.lastModifiedDate);
      for (var k in graphAttributes) {
        if (k !== "lastModifiedDate")
          writer.writeElement(k, graphAttributes[k]);
      }
      writer.endElement();
      writer.startElement("graph");
      writer.defaultEdgeType = graph.type === "mixed" ? "directed" : graph.type;
      writer.writeAttribute(
        "defaultedgetype",
        writer.defaultEdgeType
      );
      var nodes = collectNodeData(graph, DEFAULT_NODE_REDUCER), edges = collectEdgeData(graph, DEFAULT_EDGE_REDUCER);
      var nodeModel = inferModel(nodes);
      writeModel(writer, nodeModel, "node");
      var edgeModel = inferModel(edges);
      writeModel(writer, edgeModel, "edge");
      writeElements(writer, "node", nodeModel, nodes);
      writeElements(writer, "edge", edgeModel, edges);
      return writer.toString();
    };
  }
});

// node_modules/graphology-gexf/browser/index.js
var require_browser = __commonJS({
  "node_modules/graphology-gexf/browser/index.js"(exports) {
    exports.parse = require_parser();
    exports.write = require_writer();
  }
});
export default require_browser();
//# sourceMappingURL=graphology-gexf_browser.js.map
