{
  "version": 3,
  "sources": ["../../@sigma/layer-leaflet/dist/sigma-layer-leaflet.esm.js"],
  "sourcesContent": ["import L, { LatLngBounds } from 'leaflet';\r\n\r\nfunction _toPrimitive(t, r) {\r\n  if (\"object\" != typeof t || !t) return t;\r\n  var e = t[Symbol.toPrimitive];\r\n  if (void 0 !== e) {\r\n    var i = e.call(t, r || \"default\");\r\n    if (\"object\" != typeof i) return i;\r\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\r\n  }\r\n  return (\"string\" === r ? String : Number)(t);\r\n}\r\n\r\nfunction _toPropertyKey(t) {\r\n  var i = _toPrimitive(t, \"string\");\r\n  return \"symbol\" == typeof i ? i : i + \"\";\r\n}\r\n\r\nfunction _defineProperty(e, r, t) {\r\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\r\n    value: t,\r\n    enumerable: !0,\r\n    configurable: !0,\r\n    writable: !0\r\n  }) : e[r] = t, e;\r\n}\r\n\r\nfunction ownKeys(e, r) {\r\n  var t = Object.keys(e);\r\n  if (Object.getOwnPropertySymbols) {\r\n    var o = Object.getOwnPropertySymbols(e);\r\n    r && (o = o.filter(function (r) {\r\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\r\n    })), t.push.apply(t, o);\r\n  }\r\n  return t;\r\n}\r\nfunction _objectSpread2(e) {\r\n  for (var r = 1; r < arguments.length; r++) {\r\n    var t = null != arguments[r] ? arguments[r] : {};\r\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\r\n      _defineProperty(e, r, t[r]);\r\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\r\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\r\n    });\r\n  }\r\n  return e;\r\n}\r\n\r\nvar LEAFLET_MAX_PIXEL = 256 * Math.pow(2, 18);\r\nvar MAX_VALID_LATITUDE = 85.051129;\r\n/**\r\n * Get the world size in pixel\r\n */\r\nfunction getWorldPixelSize(map) {\r\n  var southWest = map.project({\r\n    lat: -MAX_VALID_LATITUDE,\r\n    lng: -180\r\n  });\r\n  var northEast = map.project({\r\n    lat: MAX_VALID_LATITUDE,\r\n    lng: 180\r\n  });\r\n  return {\r\n    y: Math.abs(southWest.y - northEast.y),\r\n    x: Math.abs(northEast.x - southWest.x)\r\n  };\r\n}\r\n\r\n/**\r\n * Given a geo point returns its graph coords.\r\n */\r\nfunction latlngToGraph(map, coord) {\r\n  var data = map.project({\r\n    lat: coord.lat,\r\n    lng: coord.lng\r\n  }, 0);\r\n  return {\r\n    x: data.x,\r\n    // Y are reversed between geo / sigma\r\n    y: map.getContainer().clientHeight - data.y\r\n  };\r\n}\r\n\r\n/**\r\n * Given a graph coords returns its lat/lng coords.\r\n */\r\nfunction graphToLatlng(map, coords) {\r\n  var data = map.unproject([coords.x, map.getContainer().clientHeight - coords.y], 0);\r\n  return {\r\n    lat: data.lat,\r\n    lng: data.lng\r\n  };\r\n}\r\n\r\n/**\r\n * Synchronise sigma BBOX with the Map one.\r\n */\r\nfunction syncSigmaWithMap(sigma, map) {\r\n  var mapBound = map.getBounds();\r\n\r\n  // Compute sigma center\r\n  var center = sigma.viewportToFramedGraph(sigma.graphToViewport(latlngToGraph(map, mapBound.getCenter())));\r\n\r\n  // Compute sigma ratio\r\n  var northEast = sigma.graphToViewport(latlngToGraph(map, mapBound.getNorthEast()));\r\n  var southWest = sigma.graphToViewport(latlngToGraph(map, mapBound.getSouthWest()));\r\n  var viewportBoundDimension = {\r\n    width: Math.abs(northEast.x - southWest.x),\r\n    height: Math.abs(northEast.y - southWest.y)\r\n  };\r\n  var viewportDim = sigma.getDimensions();\r\n  var ratio = Math.min(viewportBoundDimension.width / viewportDim.width, viewportBoundDimension.height / viewportDim.height) * sigma.getCamera().getState().ratio;\r\n  sigma.getCamera().setState(_objectSpread2(_objectSpread2({}, center), {}, {\r\n    ratio: ratio\r\n  }));\r\n}\r\n\r\n/**\r\n * Synchronise map BBOX with the Sigma one.\r\n */\r\nfunction syncMapWithSigma(sigma, map) {\r\n  var firstIteration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  var viewportDimensions = sigma.getDimensions();\r\n\r\n  // Graph BBox\r\n  var graphBottomLeft = sigma.viewportToGraph({\r\n    x: 0,\r\n    y: viewportDimensions.height\r\n  });\r\n  var graphTopRight = sigma.viewportToGraph({\r\n    x: viewportDimensions.width,\r\n    y: 0\r\n  });\r\n\r\n  // Geo BBox\r\n  var geoSouthWest = graphToLatlng(map, graphBottomLeft);\r\n  var geoNorthEast = graphToLatlng(map, graphTopRight);\r\n\r\n  // Set map BBox\r\n  var bounds = new LatLngBounds(geoSouthWest, geoNorthEast);\r\n  map.flyToBounds(bounds, {\r\n    animate: false\r\n  });\r\n  if (!firstIteration) {\r\n    // Handle side effects when bounds have some \"void\" area on top or bottom of the map\r\n    // When it happens, flyToBound don't really do its job and there is a translation of the graph that match the void height.\r\n    // So we have to do a pan in pixel...\r\n    var worldSize = map.getPixelWorldBounds().getSize();\r\n    var mapBottomY = map.getPixelBounds().getBottomLeft().y;\r\n    var mapTopY = map.getPixelBounds().getTopRight().y;\r\n    if (mapTopY < 0 || mapBottomY > worldSize.y) syncSigmaWithMap(sigma, map);\r\n  }\r\n}\r\n\r\n/**\r\n * Settings the min & max camera ratio of sigma to not be over the map's capabilities\r\n * - Max zoom is when whe can see the whole map\r\n * - Min zoom is when we are at zoom 18 on leaflet\r\n */\r\nfunction setSigmaRatioBounds(sigma, map) {\r\n  var worldPixelSize = getWorldPixelSize(map);\r\n\r\n  // Max zoom\r\n  var maxZoomRatio = worldPixelSize.y / sigma.getDimensions().width;\r\n  sigma.setSetting(\"maxCameraRatio\", maxZoomRatio);\r\n  // Min zoom\r\n  var minZoomRatio = worldPixelSize.y / LEAFLET_MAX_PIXEL;\r\n  sigma.setSetting(\"minCameraRatio\", minZoomRatio);\r\n  var currentRatio = sigma.getCamera().ratio;\r\n  if (currentRatio > maxZoomRatio) sigma.getCamera().setState({\r\n    ratio: maxZoomRatio\r\n  });\r\n  if (currentRatio < minZoomRatio) sigma.getCamera().setState({\r\n    ratio: minZoomRatio\r\n  });\r\n}\r\n\r\n/**\r\n * On the graph, we store the 2D projection of the geographical lat/long.\r\n *\r\n * @param sigma The sigma instance\r\n * @param opts.mapOptions Options that will be provided to the map constructor.\r\n * @param opts.tileLayer Tile layer configuration for the map (default is openstreetmap)\r\n * @param opts.getNodeLatLng Function to retrieve lat/long values from a node's attributs (default is lat & lng)\r\n */\r\nfunction bindLeafletLayer(sigma, opts) {\r\n  // Keeping data for the cleanup\r\n  var isKilled = false;\r\n  var prevSigmaSettings = sigma.getSettings();\r\n\r\n  // Creating map container\r\n  var mapLayerName = \"layer-leaflet\";\r\n  var mapContainer = sigma.createLayer(mapLayerName, \"div\", {\r\n    style: {\r\n      position: \"absolute\",\r\n      inset: \"0\",\r\n      zIndex: \"0\"\r\n    },\r\n    // 'edges' is the first sigma layer\r\n    beforeLayer: \"edges\"\r\n  });\r\n  sigma.getContainer().prepend(mapContainer);\r\n\r\n  // Initialize the map\r\n  var map = L.map(mapContainer, _objectSpread2(_objectSpread2({}, (opts === null || opts === void 0 ? void 0 : opts.mapOptions) || {}), {}, {\r\n    zoomControl: false,\r\n    zoomSnap: 0,\r\n    zoom: 0,\r\n    // we force the maxZoom with a higher tile value so leaflet function are not stuck\r\n    // in a restricted area. It avoids side effect\r\n    maxZoom: 20\r\n  })).setView([0, 0], 0);\r\n  var tileUrl = \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\";\r\n  var tileAttribution = '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\r\n  if (opts !== null && opts !== void 0 && opts.tileLayer) {\r\n    tileUrl = opts.tileLayer.urlTemplate;\r\n    tileAttribution = opts.tileLayer.attribution;\r\n  }\r\n  L.tileLayer(tileUrl, {\r\n    attribution: tileAttribution\r\n  }).addTo(map);\r\n  var mapIsMoving = false;\r\n  map.on(\"move\", function () {\r\n    mapIsMoving = true;\r\n  });\r\n  map.on(\"moveend\", function () {\r\n    mapIsMoving = false;\r\n  });\r\n\r\n  // `stagePadding: 0` is mandatory, so the bbox of the map & Sigma is the same.\r\n  sigma.setSetting(\"stagePadding\", 0);\r\n\r\n  // disable camera rotation\r\n  sigma.setSetting(\"enableCameraRotation\", false);\r\n\r\n  // Function that change the given graph by generating the sigma x,y coords by taking the geo coordinates\r\n  // and project them in the 2D space of the map\r\n  function updateGraphCoordinates(graph) {\r\n    graph.updateEachNodeAttributes(function (_node, attrs) {\r\n      var coords = latlngToGraph(map, opts !== null && opts !== void 0 && opts.getNodeLatLng ? opts.getNodeLatLng(attrs) : {\r\n        lat: attrs.lat,\r\n        lng: attrs.lng\r\n      });\r\n      return _objectSpread2(_objectSpread2({}, attrs), {}, {\r\n        x: coords.x,\r\n        y: coords.y\r\n      });\r\n    });\r\n  }\r\n\r\n  // Function that sync the map with sigma\r\n  function fnSyncMapWithSigma() {\r\n    var firstIteration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\r\n    syncMapWithSigma(sigma, map, firstIteration);\r\n  }\r\n\r\n  // Function that sync sigma with map if it's needed\r\n  function fnSyncSigmaWithMap() {\r\n    if (!sigma.getCamera().isAnimated() && !mapIsMoving) {\r\n      // Check that sigma & map are already in sync\r\n      var southWest = graphToLatlng(map, sigma.viewportToGraph({\r\n        x: 0,\r\n        y: sigma.getDimensions().height\r\n      }));\r\n      var northEast = graphToLatlng(map, sigma.viewportToGraph({\r\n        x: sigma.getDimensions().width,\r\n        y: 0\r\n      }));\r\n      var diff = Math.max(map.getBounds().getSouthWest().distanceTo(southWest), map.getBounds().getNorthEast().distanceTo(northEast));\r\n      if (diff > 10000 / map.getZoom()) {\r\n        syncSigmaWithMap(sigma, map);\r\n      }\r\n    }\r\n  }\r\n\r\n  // When sigma is resize, we need to update the graph coordinate (the ref has changed)\r\n  // and recompute the zoom bounds\r\n  function fnOnResize() {\r\n    // Ask the map to resize\r\n    // NB: resize can change the center of the map, and we want to keep it\r\n    var center = map.getCenter();\r\n    map.invalidateSize({\r\n      pan: false,\r\n      animate: false,\r\n      duration: 0\r\n    });\r\n    map.setView(center);\r\n\r\n    // Map ref has changed, we need to update the graph coordinates & bounds\r\n    updateGraphCoordinates(sigma.getGraph());\r\n    setSigmaRatioBounds(sigma, map);\r\n\r\n    // Do the sync\r\n    fnSyncSigmaWithMap();\r\n  }\r\n\r\n  // Clean up function to remove everything\r\n  function clean() {\r\n    if (!isKilled) {\r\n      isKilled = true;\r\n      map.remove();\r\n      sigma.killLayer(mapLayerName);\r\n      sigma.off(\"afterRender\", fnSyncMapWithSigma);\r\n      sigma.off(\"resize\", fnOnResize);\r\n\r\n      // Reset settings\r\n      sigma.setSetting(\"stagePadding\", prevSigmaSettings.stagePadding);\r\n      sigma.setSetting(\"enableCameraRotation\", prevSigmaSettings.enableCameraRotation);\r\n      sigma.setSetting(\"minCameraRatio\", prevSigmaSettings.minCameraRatio);\r\n      sigma.setSetting(\"maxCameraRatio\", prevSigmaSettings.maxCameraRatio);\r\n    }\r\n  }\r\n\r\n  // When the map is ready\r\n  map.whenReady(function () {\r\n    // Update the sigma graph for geospatial coords\r\n    updateGraphCoordinates(sigma.getGraph());\r\n\r\n    // Do the first sync\r\n    fnSyncMapWithSigma(true);\r\n\r\n    // Compute sigma ratio bounds\r\n    map.once(\"moveend\", function () {\r\n      setSigmaRatioBounds(sigma, map);\r\n      fnSyncSigmaWithMap();\r\n    });\r\n\r\n    // At each render of sigma, we do the map sync\r\n    sigma.on(\"afterRender\", fnSyncMapWithSigma);\r\n    // Listen on resize\r\n    sigma.on(\"resize\", fnOnResize);\r\n    // Do the cleanup\r\n    sigma.on(\"kill\", clean);\r\n  });\r\n  return {\r\n    clean: clean,\r\n    map: map,\r\n    updateGraphCoordinates: updateGraphCoordinates\r\n  };\r\n}\r\n\r\nexport { bindLeafletLayer as default, graphToLatlng, latlngToGraph };\r\n"],
  "mappings": "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",
  "names": ["r", "L"]
}
