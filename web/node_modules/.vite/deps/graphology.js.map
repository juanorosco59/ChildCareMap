{
  "version": 3,
  "sources": ["../../obliterator/iterator.js", "../../obliterator/take.js", "../../obliterator/chain.js", "../../graphology/src/utils.js", "../../graphology/src/errors.js", "../../graphology/src/data.js", "../../graphology/src/indices.js", "../../graphology/src/attributes.js", "../../graphology/src/iteration/edges.js", "../../graphology/src/iteration/neighbors.js", "../../graphology/src/iteration/adjacency.js", "../../graphology/src/serialization.js", "../../graphology/src/graph.js", "../../graphology/src/classes.js", "../../graphology/src/endpoint.esm.js"],
  "sourcesContent": ["/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n\n  // Hiding the given function\n  Object.defineProperty(this, '_next', {\n    writable: false,\n    enumerable: false,\n    value: next\n  });\n\n  // Is the iterator complete?\n  this.done = false;\n}\n\n/**\n * Next function.\n *\n * @return {object}\n */\n// NOTE: maybe this should dropped for performance?\nIterator.prototype.next = function() {\n  if (this.done)\n    return {done: true};\n\n  var step = this._next();\n\n  if (step.done)\n    this.done = true;\n\n  return step;\n};\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function() {\n  var args = arguments,\n      l = args.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function() {\n  var iterator = new Iterator(null);\n  iterator.done = true;\n\n  return iterator;\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function(value) {\n  if (value instanceof Iterator)\n    return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n", "/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\n\n/**\n * Take.\n *\n * @param  {Iterator} iterator - Target iterator.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterator, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n      array = l !== Infinity ? new Array(l) : [],\n      step,\n      i = 0;\n\n  while (true) {\n\n    if (i === l)\n      return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n\n      if (i !== n)\n        return array.slice(0, i);\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n", "/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterators.\n */\nvar Iterator = require('./iterator.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterators - Target iterators.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterators = arguments,\n      current,\n      i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterators.length)\n        return {done: true};\n\n      current = iterators[i];\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n", "/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i])\n      continue;\n\n    for (const k in arguments[i])\n      target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function')\n  assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData)\n    return edge;\n\n  if (type === 'mixed') {\n    edge = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target])\n    );\n  }\n  else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  }\n  else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o)\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  }\n  else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints))\n    return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes))\n    return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalId() {\n  let i = 0;\n\n  return () => {\n    return i++;\n  };\n}\n", "/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message, data) {\n    super();\n    this.name = 'GraphError';\n    this.message = message || '';\n    this.data = data || {};\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n", "/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n}\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n", "/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (undirected)\n    outKey = inKey = 'undirected';\n\n  let adj, container;\n\n  if (multi) {\n\n    // Handling source\n    adj = sourceData[outKey];\n    container = adj[target];\n\n    if (typeof container === 'undefined') {\n      container = new Set();\n      adj[target] = container;\n    }\n\n    container.add(edgeData);\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target (we won't add the edge because it was already taken\n    // care of with source above)\n    adj = targetData[inKey];\n    if (typeof adj[source] === 'undefined')\n      adj[source] = container;\n  }\n  else {\n\n    // Handling source\n    sourceData[outKey][target] = edgeData;\n\n    // If selfLoop, we break here\n    if (source === target && undirected)\n      return;\n\n    // Handling target\n    targetData[inKey][source] = edgeData;\n  }\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n        target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n        sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      }\n      else {\n        set.delete(edgeData);\n      }\n    }\n    else\n      delete sourceIndex[target];\n  }\n\n  if (multi)\n    return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  graph._nodes.forEach(data => {\n\n    // Clearing now useless properties\n    if (typeof data.in !== 'undefined') {\n      data.in = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n\n    // Directed\n    if (data.out) {\n\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node)\n          continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n", "/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {\n  assign,\n  isPlainObject,\n  getMatchingEdge\n} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeGetter(Class, method, type) {\n\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributesGetter(Class, method, type) {\n\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 1) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachAttributeChecker(Class, method, type) {\n\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeSetter(Class, method, type) {\n\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeUpdater(Class, method, type) {\n\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributeRemover(Class, method, type) {\n\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesReplacer(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachAttributesMerger(Class, method, type) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && data.undirected !== (type === 'undirected'))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function({name, attacher}) {\n\n    // For edges\n    attacher(\n      Graph,\n      name('Edge'),\n      'mixed'\n    );\n\n    // For directed edges\n    attacher(\n      Graph,\n      name('DirectedEdge'),\n      'directed'\n    );\n\n    // For undirected edges\n    attacher(\n      Graph,\n      name('UndirectedEdge'),\n      'undirected'\n    );\n  });\n}\n", "/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collectSimple(edges, object) {\n  for (const k in object)\n    edges.push(object[k].key);\n}\n\nfunction collectMulti(edges, object) {\n  for (const k in object)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n  }\n}\n\nfunction forEachMulti(object, callback, avoid) {\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    ));\n  }\n}\n\n/**\n * Function iterating over edges from the given object using a callback until\n * the return value of the callback is truthy.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimpleUntil(object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachMultiUntil(object, callback, avoid) {\n  let iterator, step, edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid)\n      continue;\n\n    iterator = object[k].values();\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected,\n        edgeData.generatedKey\n      );\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let inner = null,\n      i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    }\n    else {\n      if (i >= l)\n        return {done: true};\n\n      const k = keys[i];\n\n      if (k === avoid) {\n        i++;\n        return next();\n      }\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes\n      ]\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKeySimple(edges, object, k) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  edges.push(edgeData.key);\n}\n\nfunction collectForKeyMulti(edges, object, k) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => edges.push(edgeData.key));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMulti(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return;\n\n  edgesData.forEach(edgeData => callback(\n    edgeData.key,\n    edgeData.attributes,\n    edgeData.source.key,\n    edgeData.target.key,\n    edgeData.source.attributes,\n    edgeData.target.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  ));\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback until it returns a truthy value to stop iteration.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimpleUntil(object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData)\n    return false;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  return callback(\n    edgeData.key,\n    edgeData.attributes,\n    sourceData.key,\n    targetData.key,\n    sourceData.attributes,\n    targetData.attributes,\n    edgeData.undirected,\n    edgeData.generatedKey\n  );\n}\n\nfunction forEachForKeyMultiUntil(object, k, callback) {\n  const edgesData = object[k];\n\n  if (!edgesData)\n    return false;\n\n  let shouldBreak = false;\n\n  const iterator = edgesData.values();\n  let step, edgeData;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    edgeData = step.value;\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected,\n      edgeData.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: [\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.source.key,\n          edgeData.target.key,\n          edgeData.source.attributes,\n          edgeData.target.attributes\n        ]\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0)\n    return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size = type === 'undirected' ?\n    graph.undirectedSize :\n    graph.directedSize;\n\n  const list = new Array(size),\n        mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask)\n      list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n  }\n}\n\n/**\n * Function iterating over a graph's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdgeUntil(graph, type, callback) {\n  if (graph.size === 0)\n    return false;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while ((step = iterator.next(), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask)\n      continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected,\n      data.generatedKey\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0)\n    return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask)\n        continue;\n\n      break;\n    }\n\n    const value = [\n      data.key,\n      data.attributes,\n      data.source.key,\n      data.target.key,\n      data.source.attributes,\n      data.target.attributes\n    ];\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = [];\n\n  const fn = multi ? collectMulti : collectSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(edges, nodeData.in);\n    if (direction !== 'in')\n      fn(edges, nodeData.out);\n\n    // Handling self loop edge case\n    if (!direction && nodeData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(nodeData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    fn(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback, !direction ? nodeData.key : null);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback until it returns\n * a truthy value to stop iteration.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNodeUntil(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMultiUntil : forEachSimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      shouldBreak = fn(nodeData.in, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n    if (direction !== 'in') {\n      shouldBreak = fn(nodeData.out, callback, !direction ? nodeData.key : null);\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = fn(nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.out, !direction ? nodeData.key : null));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const fn = multi ? collectForKeyMulti : collectForKeySimple;\n\n  const edges = [];\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      fn(edges, sourceData.out, target);\n\n    // Handling self loop edge case\n    if (!direction && sourceData.directedSelfLoops > 0)\n      edges.splice(edges.lastIndexOf(sourceData.key), 1);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      fn(sourceData.in, target, callback);\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n        fn(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      fn(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function iterating over edges for the given path using a callback until\n * it returns a truthy value to stop iteration.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPathUntil(type, multi, direction, sourceData, target, callback) {\n  const fn = multi ? forEachForKeyMultiUntil : forEachForKeySimpleUntil;\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      shouldBreak = fn(sourceData.in, target, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n\n    if (sourceData.key !== target)\n      if (typeof sourceData.out !== 'undefined' && direction !== 'in') {\n        shouldBreak = fn(sourceData.out, target, callback, !direction ? sourceData.key : null);\n\n        if (shouldBreak)\n          return true;\n      }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      shouldBreak = fn(sourceData.undirected, target, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length)\n      return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(type, this.multi, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdgeUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback and breaking as soon as the callback return a truthy value.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdgeUntil(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNodeUntil(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachUntilName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPathUntil(type, this.multi, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachUntilName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nexport function attachEdgeIteratorCreator(Class, description) {\n  const {\n    name: originalName,\n    type,\n    direction\n  } = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length)\n      return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachForEachEdgeUntil(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n", "/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined')\n    return;\n\n  for (const neighbor in object)\n    neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback until it returns a truthy value to stop iteration.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectUntil(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachInObjectOnceUntil(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    const shouldBreak = callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\nfunction forEachNeighborForNodeUntil(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectUntil(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObjectUntil(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  let shouldBreak = false;\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.in, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n    if (direction !== 'in') {\n      shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.out, callback);\n\n      if (shouldBreak)\n        return true;\n    }\n  }\n\n  if (type !== 'directed') {\n    shouldBreak = forEachInObjectOnceUntil(visited, nodeData, nodeData.undirected, callback);\n\n    if (shouldBreak)\n      return true;\n  }\n\n  return false;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));\n    }\n    if (direction !== 'in') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    }\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n\n  return false;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (arguments.length === 2) {\n      const node1 = '' + arguments[0],\n            node2 = '' + arguments[1];\n\n      if (!this._nodes.has(node1))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node1}\" node in the graph.`);\n\n      if (!this._nodes.has(node2))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node2}\" node in the graph.`);\n\n      // Here, we want to assess whether the two given nodes are neighbors\n      return nodeHasNeighbor(\n        this,\n        type,\n        direction,\n        node1,\n        node2\n      );\n    }\n    else if (arguments.length === 1) {\n      node = '' + node;\n\n      const nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node}\" node in the graph.`);\n\n      // Here, we want to iterate over a node's relevant neighbors\n      const neighbors = createNeighborArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n\n      return neighbors;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighborUntil(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachUntilName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1) + 'Until';\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachUntilName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachUntilName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighborForNodeUntil(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachForEachNeighborUntil(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n", "/**\n * Graphology Adjacency Iteration\n * ================================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\nimport Iterator from 'obliterator/iterator';\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph     - Target Graph instance.\n * @param {callback} function  - Iteration callback.\n */\nexport function forEachAdjacencySimple(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return true;\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n        targetData = edgeData.target;\n\n        if (targetData.key !== neighbor)\n          targetData = edgeData.source;\n\n        shouldBreak = callback(\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.undirected,\n          edgeData.generatedKey\n        );\n\n        if (breakable && shouldBreak)\n          return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Function iterating over a multi graph's adjacency using a callback.\n *\n * @param {boolean}  breakable - Can we break?\n * @param {Graph}    graph    - Target Graph instance.\n * @param {callback} function - Iteration callback.\n */\nexport function forEachAdjacencyMulti(breakable, graph, callback) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, container, containerStep, adj, edgeData, targetData, shouldBreak;\n\n  while ((step = iterator.next(), step.done !== true)) {\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return true;\n        }\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        container = adj[neighbor].values();\n\n        while ((containerStep = container.next(), containerStep.done !== true)) {\n          edgeData = containerStep.value;\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor)\n            targetData = edgeData.source;\n\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected,\n            edgeData.generatedKey\n          );\n\n          if (breakable && shouldBreak)\n            return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function createAdjacencyIteratorSimple(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    const neighbor = neighbors[offset++];\n    const edgeData = adj[neighbor];\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n\nexport function createAdjacencyIteratorMulti(graph) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let state = 'outer',\n      sourceData,\n      neighbors,\n      container = null,\n      adj,\n      offset;\n\n  return new Iterator(function next() {\n    let step;\n\n    if (state === 'outer') {\n      step = iterator.next();\n\n      if (step.done === true)\n        return step;\n\n      sourceData = step.value;\n\n      state = 'directed';\n      return next();\n    }\n\n    if (state === 'directed') {\n      if (type === 'undirected') {\n        state = 'undirected';\n        return next();\n      }\n\n      adj = sourceData.out;\n      neighbors = Object.keys(sourceData.out);\n      offset = 0;\n      state = 'inner-directed';\n\n      return next();\n    }\n\n    if (state === 'undirected') {\n      if (type === 'directed') {\n        state = 'outer';\n        return next();\n      }\n\n      adj = sourceData.undirected;\n      neighbors = Object.keys(sourceData.undirected);\n      offset = 0;\n      state = 'inner-undirected';\n    }\n\n    // Inner\n    if (!container && offset >= neighbors.length) {\n      if (state === 'inner-undirected')\n        state = 'outer';\n      else\n        state = 'undirected';\n\n      return next();\n    }\n\n    if (!container) {\n      const neighbor = neighbors[offset++];\n      container = adj[neighbor].values();\n      return next();\n    }\n\n    step = container.next();\n\n    if (step.done) {\n      container = null;\n      return next();\n    }\n\n    const edgeData = step.value;\n    let targetData = edgeData.target;\n\n    if (state === 'inner-undirected' && targetData.key === sourceData.key)\n      targetData = edgeData.source;\n\n    return {\n      done: false,\n      value: [\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.key,\n        edgeData.attributes\n      ]\n    };\n  });\n}\n", "/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  // We export the key unless if it was provided by the user\n  if (!data.generatedKey)\n    serialized.key = key;\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data.undirected)\n    serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('key' in value))\n    return 'no-key';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('source' in value))\n    return 'no-source';\n\n  if (!('target' in value))\n    return 'no-target';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  if ('undirected' in value &&\n      (typeof value.undirected !== 'boolean'))\n    return 'invalid-undirected';\n\n  return null;\n}\n", "/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\nimport {\n  forEachAdjacencySimple,\n  forEachAdjacencyMulti,\n  createAdjacencyIteratorSimple,\n  createAdjacencyIteratorMulti\n} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalId,\n  validateHints\n} from './utils';\n\n/**\n * Enums.\n */\nconst TYPES = new Set([\n  'directed',\n  'undirected',\n  'mixed'\n]);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`,\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(`Graph.addNode: the \"${node}\" node already exist in the graph.`);\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  const sourceData = graph._nodes.get(source),\n        targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(`Graph.${name}: source node \"${source}\" not found.`);\n\n  if (!targetData)\n    throw new NotFoundGraphError(`Graph.${name}: target node \"${target}\" not found.`);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    throw new UsageGraphError(`Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`);\n    }\n    else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  let sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        (edgeData.source.key !== source || edgeData.target.key !== target) ||\n        (undirected && (edgeData.source.key !== target || edgeData.target.key !== source))\n      ) {\n        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`);\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !alreadyExistingEdgeData &&\n    !graph.multi &&\n    sourceData\n  ) {\n    alreadyExistingEdgeData = undirected ?\n      sourceData.undirected[target] :\n      sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes)\n      return alreadyExistingEdgeData.key;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return alreadyExistingEdgeData.key;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater)\n    attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n\n    if (source === target)\n      targetData = sourceData;\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(\n    undirected,\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected) {\n      sourceData.undirectedSelfLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n    else {\n      sourceData.directedSelfLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"${options.edgeKeyGenerator}\".`);\n\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`);\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`);\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`);\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass = options.type === 'mixed' ?\n      MixedNodeData :\n      (options.type === 'directed') ?\n        DirectedNodeData :\n        UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(this, 'selfLoopCount', () => this._directedSelfLoopCount + this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'directedSelfLoopCount', () => this._directedSelfLoopCount);\n    readOnlyProperty(this, 'undirectedSelfLoopCount', () => this._undirectedSelfLoopCount);\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'undirected')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        !edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'directed')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData.undirected\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n\n    if (this.type === 'undirected')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n\n    if (this.type === 'directed')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined\n    );\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.inDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.inDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.outDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.outDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.directedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    const inDegree = nodeData.inDegree + loops;\n    const outDegree = nodeData.outDegree + loops;\n\n    return inDegree + outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'directed')\n      return 0;\n\n    const loops = selfLoops ? nodeData.undirectedSelfLoops : 0;\n\n    return nodeData.undirectedDegree + loops * 2;\n  }\n\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.degree: could not find the \"${node}\" node in the graph.`);\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      if (selfLoops)\n        loops = nodeData.undirectedSelfLoops;\n\n      degree += nodeData.undirectedDegree + loops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      if (selfLoops)\n        loops = nodeData.directedSelfLoops;\n\n      degree += nodeData.inDegree + nodeData.outDegree + loops * 2;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.source: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.target: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(`Graph.extremities: could not find the \"${edge}\" edge in the graph.`);\n\n    return [\n      edgeData.source.key,\n      edgeData.target.key\n    ];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${edge}\" edge in the graph.`);\n\n    const source = data.source.key,\n          target = data.target.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(`Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`);\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`);\n\n    return (\n      data.source.key === node ||\n      data.target.key === node\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isDirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source === data.target;\n  }\n\n  /**\n   * Method returning whether the given edge has a generated key.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  hasGeneratedKey(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasGeneratedKey: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.generatedKey;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`);\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return node;\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.dropNode: could not find the \"${node}\" node in the graph.`);\n\n    // Removing attached edges\n    // TODO: we could do faster\n    this.forEachEdge(node, edge => {\n      this.dropEdge(edge);\n    });\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n            target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`);\n    }\n    else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`);\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {\n      source: sourceData,\n      target: targetData,\n      attributes\n    } = edgeData;\n\n    const undirected = edgeData.undirected;\n\n    if (sourceData === targetData) {\n      if (undirected) {\n        sourceData.undirectedSelfLoops--;\n        this._undirectedSelfLoopCount--;\n      }\n      else {\n        sourceData.directedSelfLoops--;\n        this._directedSelfLoopCount--;\n      }\n    }\n    else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      }\n      else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected)\n      this._undirectedSize--;\n    else\n      this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing indices\n    this.clearIndex();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.removeNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: expecting an updater function.');\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError('Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}');\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      edgeData = step.value;\n      edgeData.attributes = updater(edgeData.key, edgeData.attributes);\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      forEachAdjacencyMulti(false, this, callback);\n    else\n      forEachAdjacencySimple(false, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    if (this.multi)\n      return forEachAdjacencyMulti(true, this, callback);\n\n    return forEachAdjacencySimple(true, this, callback);\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    if (this.multi)\n      return createAdjacencyIteratorMulti(this);\n\n    return createAdjacencyIteratorSimple(this);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function')\n      return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach((data, key) => {\n      callback(key, data.attributes);\n    });\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback until\n   * it returns a truthy value to stop iteration.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNodeUntil(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData, shouldBreak;\n\n    while ((step = iterator.next(), step.done !== true)) {\n      nodeData = step.value;\n\n      shouldBreak = callback(nodeData.key, nodeData.attributes);\n\n      if (shouldBreak)\n        return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      return {value: [data.key, data.attributes], done: false};\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportNode: could not find the \"${node}\" node in the graph.`);\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`);\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges,\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      }\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge)\n      this.mergeNode(key, attributes);\n    else\n      this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    }\n\n    // Adding the edge\n    const {\n      source,\n      target,\n      attributes = {},\n      undirected = false\n    } = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :\n        (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);\n\n      method.call(\n        this,\n        data.key,\n        source,\n        target,\n        attributes\n      );\n    }\n    else {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :\n        (undirected ? this.addUndirectedEdge : this.addDirectedEdge);\n\n      method.call(\n        this,\n        source,\n        target,\n        attributes\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n\n    // Importing a Graph instance\n    if (isGraph(data)) {\n\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');\n\n      if (merge)\n        this.mergeAttributes(data.attributes);\n      else\n        this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid nodes. Expecting an array.');\n\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importNode(list[i], merge);\n    }\n\n    if (data.edges) {\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid edges. Expecting an array.');\n\n      for (i = 0, l = list.length; i < l; i++)\n        this.importEdge(list[i], merge);\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = new Graph(this._options);\n    graph.import(this);\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed')\n      return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => (data.upgradeToMixed()));\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi)\n      return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  clearIndex() {\n    clearStructureIndex(this);\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n          multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      const desc = `(${data.source.key})${direction}(${data.target.key})`;\n\n      if (!data.generatedKey) {\n        label += `[${key}]: `;\n      }\n      else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        }\n        else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (this.hasOwnProperty(k) &&\n          !EMITTER_PROPS.has(k) &&\n          typeof this[k] !== 'function')\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb),\n          fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function(source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n    else {\n      Graph.prototype[name] = function(edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n", "/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'directed')\n    throw new InvalidArgumentsGraphError('DirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('UndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError('MultiDirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!');\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError('MultiUndirectedGraph.from: inconsistent \"' + finalOptions.type + '\" type in given options!');\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function(data, options) {\n\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n", "/**\n * Graphology ESM Endoint\n * =======================\n *\n * Endpoint for ESM modules consumers.\n */\nimport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n} from './classes';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nexport default Graph;\n\nexport {\n  Graph,\n\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph,\n\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n};\n"],
  "mappings": "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",
  "names": ["Iterator", "take", "Iterator", "chain", "Graph", "Iterator", "take", "chain", "merge"]
}
