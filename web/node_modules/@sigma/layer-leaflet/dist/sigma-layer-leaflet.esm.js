import L, { LatLngBounds } from 'leaflet';

function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

var LEAFLET_MAX_PIXEL = 256 * Math.pow(2, 18);
var MAX_VALID_LATITUDE = 85.051129;
/**
 * Get the world size in pixel
 */
function getWorldPixelSize(map) {
  var southWest = map.project({
    lat: -MAX_VALID_LATITUDE,
    lng: -180
  });
  var northEast = map.project({
    lat: MAX_VALID_LATITUDE,
    lng: 180
  });
  return {
    y: Math.abs(southWest.y - northEast.y),
    x: Math.abs(northEast.x - southWest.x)
  };
}

/**
 * Given a geo point returns its graph coords.
 */
function latlngToGraph(map, coord) {
  var data = map.project({
    lat: coord.lat,
    lng: coord.lng
  }, 0);
  return {
    x: data.x,
    // Y are reversed between geo / sigma
    y: map.getContainer().clientHeight - data.y
  };
}

/**
 * Given a graph coords returns its lat/lng coords.
 */
function graphToLatlng(map, coords) {
  var data = map.unproject([coords.x, map.getContainer().clientHeight - coords.y], 0);
  return {
    lat: data.lat,
    lng: data.lng
  };
}

/**
 * Synchronise sigma BBOX with the Map one.
 */
function syncSigmaWithMap(sigma, map) {
  var mapBound = map.getBounds();

  // Compute sigma center
  var center = sigma.viewportToFramedGraph(sigma.graphToViewport(latlngToGraph(map, mapBound.getCenter())));

  // Compute sigma ratio
  var northEast = sigma.graphToViewport(latlngToGraph(map, mapBound.getNorthEast()));
  var southWest = sigma.graphToViewport(latlngToGraph(map, mapBound.getSouthWest()));
  var viewportBoundDimension = {
    width: Math.abs(northEast.x - southWest.x),
    height: Math.abs(northEast.y - southWest.y)
  };
  var viewportDim = sigma.getDimensions();
  var ratio = Math.min(viewportBoundDimension.width / viewportDim.width, viewportBoundDimension.height / viewportDim.height) * sigma.getCamera().getState().ratio;
  sigma.getCamera().setState(_objectSpread2(_objectSpread2({}, center), {}, {
    ratio: ratio
  }));
}

/**
 * Synchronise map BBOX with the Sigma one.
 */
function syncMapWithSigma(sigma, map) {
  var firstIteration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var viewportDimensions = sigma.getDimensions();

  // Graph BBox
  var graphBottomLeft = sigma.viewportToGraph({
    x: 0,
    y: viewportDimensions.height
  });
  var graphTopRight = sigma.viewportToGraph({
    x: viewportDimensions.width,
    y: 0
  });

  // Geo BBox
  var geoSouthWest = graphToLatlng(map, graphBottomLeft);
  var geoNorthEast = graphToLatlng(map, graphTopRight);

  // Set map BBox
  var bounds = new LatLngBounds(geoSouthWest, geoNorthEast);
  map.flyToBounds(bounds, {
    animate: false
  });
  if (!firstIteration) {
    // Handle side effects when bounds have some "void" area on top or bottom of the map
    // When it happens, flyToBound don't really do its job and there is a translation of the graph that match the void height.
    // So we have to do a pan in pixel...
    var worldSize = map.getPixelWorldBounds().getSize();
    var mapBottomY = map.getPixelBounds().getBottomLeft().y;
    var mapTopY = map.getPixelBounds().getTopRight().y;
    if (mapTopY < 0 || mapBottomY > worldSize.y) syncSigmaWithMap(sigma, map);
  }
}

/**
 * Settings the min & max camera ratio of sigma to not be over the map's capabilities
 * - Max zoom is when whe can see the whole map
 * - Min zoom is when we are at zoom 18 on leaflet
 */
function setSigmaRatioBounds(sigma, map) {
  var worldPixelSize = getWorldPixelSize(map);

  // Max zoom
  var maxZoomRatio = worldPixelSize.y / sigma.getDimensions().width;
  sigma.setSetting("maxCameraRatio", maxZoomRatio);
  // Min zoom
  var minZoomRatio = worldPixelSize.y / LEAFLET_MAX_PIXEL;
  sigma.setSetting("minCameraRatio", minZoomRatio);
  var currentRatio = sigma.getCamera().ratio;
  if (currentRatio > maxZoomRatio) sigma.getCamera().setState({
    ratio: maxZoomRatio
  });
  if (currentRatio < minZoomRatio) sigma.getCamera().setState({
    ratio: minZoomRatio
  });
}

/**
 * On the graph, we store the 2D projection of the geographical lat/long.
 *
 * @param sigma The sigma instance
 * @param opts.mapOptions Options that will be provided to the map constructor.
 * @param opts.tileLayer Tile layer configuration for the map (default is openstreetmap)
 * @param opts.getNodeLatLng Function to retrieve lat/long values from a node's attributs (default is lat & lng)
 */
function bindLeafletLayer(sigma, opts) {
  // Keeping data for the cleanup
  var isKilled = false;
  var prevSigmaSettings = sigma.getSettings();

  // Creating map container
  var mapLayerName = "layer-leaflet";
  var mapContainer = sigma.createLayer(mapLayerName, "div", {
    style: {
      position: "absolute",
      inset: "0",
      zIndex: "0"
    },
    // 'edges' is the first sigma layer
    beforeLayer: "edges"
  });
  sigma.getContainer().prepend(mapContainer);

  // Initialize the map
  var map = L.map(mapContainer, _objectSpread2(_objectSpread2({}, (opts === null || opts === void 0 ? void 0 : opts.mapOptions) || {}), {}, {
    zoomControl: false,
    zoomSnap: 0,
    zoom: 0,
    // we force the maxZoom with a higher tile value so leaflet function are not stuck
    // in a restricted area. It avoids side effect
    maxZoom: 20
  })).setView([0, 0], 0);
  var tileUrl = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";
  var tileAttribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';
  if (opts !== null && opts !== void 0 && opts.tileLayer) {
    tileUrl = opts.tileLayer.urlTemplate;
    tileAttribution = opts.tileLayer.attribution;
  }
  L.tileLayer(tileUrl, {
    attribution: tileAttribution
  }).addTo(map);
  var mapIsMoving = false;
  map.on("move", function () {
    mapIsMoving = true;
  });
  map.on("moveend", function () {
    mapIsMoving = false;
  });

  // `stagePadding: 0` is mandatory, so the bbox of the map & Sigma is the same.
  sigma.setSetting("stagePadding", 0);

  // disable camera rotation
  sigma.setSetting("enableCameraRotation", false);

  // Function that change the given graph by generating the sigma x,y coords by taking the geo coordinates
  // and project them in the 2D space of the map
  function updateGraphCoordinates(graph) {
    graph.updateEachNodeAttributes(function (_node, attrs) {
      var coords = latlngToGraph(map, opts !== null && opts !== void 0 && opts.getNodeLatLng ? opts.getNodeLatLng(attrs) : {
        lat: attrs.lat,
        lng: attrs.lng
      });
      return _objectSpread2(_objectSpread2({}, attrs), {}, {
        x: coords.x,
        y: coords.y
      });
    });
  }

  // Function that sync the map with sigma
  function fnSyncMapWithSigma() {
    var firstIteration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    syncMapWithSigma(sigma, map, firstIteration);
  }

  // Function that sync sigma with map if it's needed
  function fnSyncSigmaWithMap() {
    if (!sigma.getCamera().isAnimated() && !mapIsMoving) {
      // Check that sigma & map are already in sync
      var southWest = graphToLatlng(map, sigma.viewportToGraph({
        x: 0,
        y: sigma.getDimensions().height
      }));
      var northEast = graphToLatlng(map, sigma.viewportToGraph({
        x: sigma.getDimensions().width,
        y: 0
      }));
      var diff = Math.max(map.getBounds().getSouthWest().distanceTo(southWest), map.getBounds().getNorthEast().distanceTo(northEast));
      if (diff > 10000 / map.getZoom()) {
        syncSigmaWithMap(sigma, map);
      }
    }
  }

  // When sigma is resize, we need to update the graph coordinate (the ref has changed)
  // and recompute the zoom bounds
  function fnOnResize() {
    // Ask the map to resize
    // NB: resize can change the center of the map, and we want to keep it
    var center = map.getCenter();
    map.invalidateSize({
      pan: false,
      animate: false,
      duration: 0
    });
    map.setView(center);

    // Map ref has changed, we need to update the graph coordinates & bounds
    updateGraphCoordinates(sigma.getGraph());
    setSigmaRatioBounds(sigma, map);

    // Do the sync
    fnSyncSigmaWithMap();
  }

  // Clean up function to remove everything
  function clean() {
    if (!isKilled) {
      isKilled = true;
      map.remove();
      sigma.killLayer(mapLayerName);
      sigma.off("afterRender", fnSyncMapWithSigma);
      sigma.off("resize", fnOnResize);

      // Reset settings
      sigma.setSetting("stagePadding", prevSigmaSettings.stagePadding);
      sigma.setSetting("enableCameraRotation", prevSigmaSettings.enableCameraRotation);
      sigma.setSetting("minCameraRatio", prevSigmaSettings.minCameraRatio);
      sigma.setSetting("maxCameraRatio", prevSigmaSettings.maxCameraRatio);
    }
  }

  // When the map is ready
  map.whenReady(function () {
    // Update the sigma graph for geospatial coords
    updateGraphCoordinates(sigma.getGraph());

    // Do the first sync
    fnSyncMapWithSigma(true);

    // Compute sigma ratio bounds
    map.once("moveend", function () {
      setSigmaRatioBounds(sigma, map);
      fnSyncSigmaWithMap();
    });

    // At each render of sigma, we do the map sync
    sigma.on("afterRender", fnSyncMapWithSigma);
    // Listen on resize
    sigma.on("resize", fnOnResize);
    // Do the cleanup
    sigma.on("kill", clean);
  });
  return {
    clean: clean,
    map: map,
    updateGraphCoordinates: updateGraphCoordinates
  };
}

export { bindLeafletLayer as default, graphToLatlng, latlngToGraph };
